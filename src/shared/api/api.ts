/* tslint:disable */
/* eslint-disable */
/**
 * onperm-hipster-timer-backend
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 가시성 설정 DTO
 */
export interface AppDomainScheduleSchemaDtoVisibilitySettings {
    'level'?: VisibilityLevel;
    'allowed_user_ids'?: Array<string> | null;
}


/**
 * 참여자별 가능 시간 조회 DTO
 */
export interface AvailabilityRead {
    'participant': ParticipantRead;
    'time_slots': Array<TimeSlotRead>;
}
/**
 * Schedule 생성 시 함께 생성할 Todo 옵션
 */
export interface CreateTodoOptions {
    'tag_group_id': string;
}
/**
 * 친구 정보 조회 DTO (간략화)
 */
export interface FriendRead {
    'user_id': string;
    'friendship_id': string;
    'since': string;
}
/**
 * 친구 요청 DTO
 */
export interface FriendRequest {
    'addressee_id': string;
}
/**
 * 친구 관계 조회 DTO
 */
export interface FriendshipRead {
    'id': string;
    'requester_id': string;
    'addressee_id': string;
    'status': FriendshipStatus;
    'blocked_by'?: string | null;
    'created_at': string;
    'updated_at': string;
}


/**
 * 친구 관계 상태
 */

export const FriendshipStatus = {
    Pending: 'pending',
    Accepted: 'accepted',
    Blocked: 'blocked'
} as const;

export type FriendshipStatus = typeof FriendshipStatus[keyof typeof FriendshipStatus];


export interface HTTPValidationError {
    'detail'?: Array<ValidationError>;
}
/**
 * 도메인 국경일 정보 항목 (정제된 데이터)
 */
export interface HolidayItem {
    'locdate': string;
    'seq': number;
    'dateKind': string;
    'dateName': string;
    'isHoliday': boolean;
}
/**
 * 일정 조율 생성 DTO
 */
export interface MeetingCreate {
    'title': string;
    'description'?: string | null;
    'start_date': string;
    'end_date': string;
    'available_days': Array<number>;
    'start_time': string;
    'end_time': string;
    'time_slot_minutes'?: number;
    'visibility'?: VisibilitySettings | null;
}
/**
 * 일정 조율 조회 DTO
 */
export interface MeetingRead {
    'id': string;
    'owner_id': string;
    'title': string;
    'description'?: string | null;
    'start_date': string;
    'end_date': string;
    'available_days': Array<number>;
    'start_time': string;
    'end_time': string;
    'time_slot_minutes': number;
    'created_at': string;
    'updated_at': string;
    'visibility_level'?: VisibilityLevel | null;
    'is_shared'?: boolean;
}


/**
 * 공통 가능 시간 분석 결과 DTO
 */
export interface MeetingResultRead {
    'meeting': MeetingRead;
    'availability_grid': { [key: string]: { [key: string]: number; }; };
}
/**
 * 일정 조율 업데이트 DTO
 */
export interface MeetingUpdate {
    'title'?: string | null;
    'description'?: string | null;
    'start_date'?: string | null;
    'end_date'?: string | null;
    'available_days'?: Array<number> | null;
    'start_time'?: string | null;
    'end_time'?: string | null;
    'time_slot_minutes'?: number | null;
    'visibility'?: VisibilitySettings | null;
}
/**
 * 참여자 생성 DTO
 */
export interface ParticipantCreate {
    'display_name': string;
}
/**
 * 참여자 조회 DTO
 */
export interface ParticipantRead {
    'id': string;
    'meeting_id': string;
    'user_id'?: string | null;
    'display_name': string;
    'created_at': string;
}
/**
 * 대기 중인 친구 요청 DTO
 */
export interface PendingRequestRead {
    'id': string;
    'requester_id': string;
    'addressee_id': string;
    'created_at': string;
}
/**
 * 프리셋 전체 정의  프리셋 JSON 파일의 루트 구조입니다. 하나의 TagGroup과 그에 속한 Tag들, Todo들을 정의합니다.
 */
export interface Preset {
    'name': string;
    'description'?: string | null;
    'tag_group': PresetTagGroup;
    'tags'?: Array<PresetTag>;
    'todos'?: Array<PresetTodo>;
}
/**
 * 프리셋 목록 조회용 간략 정보
 */
export interface PresetInfo {
    'name': string;
    'description'?: string | null;
    'tag_count': number;
    'todo_count': number;
}
/**
 * 프리셋 초기화 결과
 */
export interface PresetInitializeResult {
    'preset_name': string;
    'tag_group_id': string;
    'tags_created': number;
    'todos_created': number;
}
/**
 * 프리셋 태그 정의
 */
export interface PresetTag {
    'name': string;
    'color': string;
    'description'?: string | null;
}
/**
 * 프리셋 태그 그룹 정의
 */
export interface PresetTagGroup {
    'name': string;
    'color': string;
    'description'?: string | null;
    'goal_ratios'?: { [key: string]: number; } | null;
    'is_todo_group'?: boolean;
}
/**
 * 프리셋 Todo 정의 (계층 구조 지원)  tag_names: 이 Todo에 연결할 태그 이름 리스트 children: 자식 Todo 리스트 (재귀적 구조)
 */
export interface PresetTodo {
    'title': string;
    'description'?: string | null;
    'tag_names'?: Array<string> | null;
    'children'?: Array<PresetTodo> | null;
}
/**
 * 리소스 조회 범위 (공유 리소스 포함 여부)
 */

export const ResourceScope = {
    Mine: 'mine',
    Shared: 'shared',
    All: 'all'
} as const;

export type ResourceScope = typeof ResourceScope[keyof typeof ResourceScope];


/**
 * 일정 생성 DTO
 */
export interface ScheduleCreate {
    'title': string;
    'description'?: string | null;
    'start_time': string;
    'end_time': string;
    'recurrence_rule'?: string | null;
    'recurrence_end'?: string | null;
    'tag_ids'?: Array<string> | null;
    'tag_group_id'?: string | null;
    'source_todo_id'?: string | null;
    'state'?: ScheduleState | null;
    'create_todo_options'?: CreateTodoOptions | null;
    'visibility'?: AppDomainScheduleSchemaDtoVisibilitySettings | null;
}


/**
 * 일정 조회 DTO
 */
export interface ScheduleRead {
    'id': string;
    'title': string;
    'description'?: string | null;
    'start_time': string;
    'end_time': string;
    'recurrence_rule'?: string | null;
    'recurrence_end'?: string | null;
    'parent_id'?: string | null;
    'tag_group_id'?: string | null;
    'source_todo_id'?: string | null;
    'state': ScheduleState;
    'created_at': string;
    'tags'?: Array<TagRead>;
    'owner_id'?: string | null;
    'visibility_level'?: VisibilityLevel | null;
    'is_shared'?: boolean;
}


/**
 * Schedule 상태
 */

export const ScheduleState = {
    Planned: 'PLANNED',
    Confirmed: 'CONFIRMED',
    Cancelled: 'CANCELLED'
} as const;

export type ScheduleState = typeof ScheduleState[keyof typeof ScheduleState];


/**
 * 일정 업데이트 DTO
 */
export interface ScheduleUpdate {
    'title'?: string | null;
    'description'?: string | null;
    'start_time'?: string | null;
    'end_time'?: string | null;
    'recurrence_rule'?: string | null;
    'recurrence_end'?: string | null;
    'tag_ids'?: Array<string> | null;
    'tag_group_id'?: string | null;
    'source_todo_id'?: string | null;
    'state'?: ScheduleState | null;
    'visibility'?: AppDomainScheduleSchemaDtoVisibilitySettings | null;
}


/**
 * 태그 생성 DTO
 */
export interface TagCreate {
    'name': string;
    'color': string;
    'description'?: string | null;
    'group_id': string;
}
/**
 * 태그 그룹 생성 DTO
 */
export interface TagGroupCreate {
    'name': string;
    'color': string;
    'description'?: string | null;
    'goal_ratios'?: { [key: string]: number; } | null;
    'is_todo_group'?: boolean;
}
/**
 * 태그 그룹 조회 DTO
 */
export interface TagGroupRead {
    'id': string;
    'name': string;
    'color': string;
    'description'?: string | null;
    'goal_ratios'?: { [key: string]: number; } | null;
    'is_todo_group': boolean;
    'created_at': string;
    'updated_at': string;
}
/**
 * 태그 그룹 조회 DTO (태그 포함)
 */
export interface TagGroupReadWithTags {
    'id': string;
    'name': string;
    'color': string;
    'description'?: string | null;
    'goal_ratios'?: { [key: string]: number; } | null;
    'is_todo_group': boolean;
    'created_at': string;
    'updated_at': string;
    'tags'?: Array<TagRead>;
}
/**
 * 태그 그룹 업데이트 DTO
 */
export interface TagGroupUpdate {
    'name'?: string | null;
    'color'?: string | null;
    'description'?: string | null;
    'goal_ratios'?: { [key: string]: number; } | null;
    'is_todo_group'?: boolean | null;
}
/**
 * 타이머 태그 포함 모드
 */

export const TagIncludeMode = {
    None: 'none',
    TimerOnly: 'timer_only',
    InheritFromSchedule: 'inherit_from_schedule'
} as const;

export type TagIncludeMode = typeof TagIncludeMode[keyof typeof TagIncludeMode];


/**
 * 태그 조회 DTO
 */
export interface TagRead {
    'id': string;
    'name': string;
    'color': string;
    'description'?: string | null;
    'group_id': string;
    'created_at': string;
    'updated_at': string;
}
/**
 * 태그별 통계
 */
export interface TagStat {
    'tag_id': string;
    'tag_name': string;
    'count': number;
}
/**
 * 태그 업데이트 DTO
 */
export interface TagUpdate {
    'name'?: string | null;
    'color'?: string | null;
    'description'?: string | null;
}
/**
 * 시간 슬롯 생성 DTO
 */
export interface TimeSlotCreate {
    'slot_date': string;
    'start_time': string;
    'end_time': string;
}
/**
 * 시간 슬롯 조회 DTO
 */
export interface TimeSlotRead {
    'id': string;
    'participant_id': string;
    'slot_date': string;
    'start_time': string;
    'end_time': string;
}
/**
 * 타이머 조회 DTO
 */
export interface TimerRead {
    'id': string;
    'schedule_id'?: string | null;
    'todo_id'?: string | null;
    'title'?: string | null;
    'description'?: string | null;
    'allocated_duration': number;
    'elapsed_time': number;
    'status': string;
    'started_at'?: string | null;
    'paused_at'?: string | null;
    'ended_at'?: string | null;
    'created_at': string;
    'updated_at': string;
    'pause_history'?: Array<{ [key: string]: any; }>;
    'schedule'?: ScheduleRead | null;
    'todo'?: TodoRead | null;
    'tags'?: Array<TagRead>;
    'owner_id'?: string | null;
    'visibility_level'?: VisibilityLevel | null;
    'is_shared'?: boolean;
}


/**
 * 타이머 업데이트 DTO  todo_id, schedule_id 필드 동작: - 필드가 요청에 포함되지 않음 (undefined): 기존 값 유지 - 필드가 UUID 값: 해당 ID로 연결 변경 - 필드가 null: 연결 해제  Note: 자동 연결 기능은 적용되지 않음 (명시적 변경만 수행)
 */
export interface TimerUpdate {
    'title'?: string | null;
    'description'?: string | null;
    'tag_ids'?: Array<string> | null;
    'todo_id'?: string | null;
    'schedule_id'?: string | null;
    'visibility'?: AppDomainScheduleSchemaDtoVisibilitySettings | null;
}
/**
 * Todo 생성 DTO
 */
export interface TodoCreate {
    'title': string;
    'description'?: string | null;
    'tag_group_id': string;
    'tag_ids'?: Array<string> | null;
    'deadline'?: string | null;
    'parent_id'?: string | null;
    'status'?: TodoStatus | null;
    'visibility'?: AppDomainScheduleSchemaDtoVisibilitySettings | null;
}


/**
 * Todo가 응답에 포함된 사유
 */

export const TodoIncludeReason = {
    Match: 'MATCH',
    Ancestor: 'ANCESTOR'
} as const;

export type TodoIncludeReason = typeof TodoIncludeReason[keyof typeof TodoIncludeReason];


/**
 * Todo 조회 DTO
 */
export interface TodoRead {
    'id': string;
    'title': string;
    'description'?: string | null;
    'deadline'?: string | null;
    'tag_group_id': string;
    'parent_id'?: string | null;
    'status': TodoStatus;
    'created_at': string;
    'tags'?: Array<TagRead>;
    'schedules'?: Array<ScheduleRead>;
    'include_reason'?: TodoIncludeReason;
    'owner_id'?: string | null;
    'visibility_level'?: VisibilityLevel | null;
    'is_shared'?: boolean;
}


/**
 * Todo 통계
 */
export interface TodoStats {
    'group_id'?: string | null;
    'total_count': number;
    'by_tag': Array<TagStat>;
}
/**
 * Todo 상태
 */

export const TodoStatus = {
    Unscheduled: 'UNSCHEDULED',
    Scheduled: 'SCHEDULED',
    Done: 'DONE',
    Cancelled: 'CANCELLED'
} as const;

export type TodoStatus = typeof TodoStatus[keyof typeof TodoStatus];


/**
 * Todo 업데이트 DTO
 */
export interface TodoUpdate {
    'title'?: string | null;
    'description'?: string | null;
    'tag_group_id'?: string | null;
    'tag_ids'?: Array<string> | null;
    'deadline'?: string | null;
    'parent_id'?: string | null;
    'status'?: TodoStatus | null;
    'visibility'?: AppDomainScheduleSchemaDtoVisibilitySettings | null;
}


export interface ValidationError {
    'loc': Array<ValidationErrorLocInner>;
    'msg': string;
    'type': string;
}
export interface ValidationErrorLocInner {
}
/**
 * 가시성 레벨
 */

export const VisibilityLevel = {
    Private: 'private',
    Friends: 'friends',
    Selected: 'selected',
    AllowedEmails: 'allowed_emails',
    Public: 'public'
} as const;

export type VisibilityLevel = typeof VisibilityLevel[keyof typeof VisibilityLevel];


/**
 * 가시성 설정 DTO
 */
export interface VisibilitySettings {
    'level'?: VisibilityLevel;
    'allowed_user_ids'?: Array<string> | null;
    'allowed_emails'?: Array<string> | null;
    'allowed_domains'?: Array<string> | null;
}



/**
 * FriendsApi - axios parameter creator
 */
export const FriendsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 친구 요청 수락  받은 친구 요청을 수락합니다. 요청 수신자만 수락할 수 있습니다.
         * @summary Accept Friend Request
         * @param {string} friendshipId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptFriendRequestV1FriendsRequestsFriendshipIdAcceptPost: async (friendshipId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'friendshipId' is not null or undefined
            assertParamExists('acceptFriendRequestV1FriendsRequestsFriendshipIdAcceptPost', 'friendshipId', friendshipId)
            const localVarPath = `/v1/friends/requests/{friendship_id}/accept`
                .replace(`{${"friendship_id"}}`, encodeURIComponent(String(friendshipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 사용자 차단  특정 사용자를 차단합니다. 차단된 사용자는 친구 요청을 보낼 수 없고, 공유된 콘텐츠에 접근할 수 없습니다.
         * @summary Block User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockUserV1FriendsBlockUserIdPost: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('blockUserV1FriendsBlockUserIdPost', 'userId', userId)
            const localVarPath = `/v1/friends/block/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 보낸 친구 요청 취소  보낸 친구 요청을 취소합니다. 요청 발신자만 취소할 수 있습니다.
         * @summary Cancel Friend Request
         * @param {string} friendshipId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelFriendRequestV1FriendsRequestsFriendshipIdDelete: async (friendshipId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'friendshipId' is not null or undefined
            assertParamExists('cancelFriendRequestV1FriendsRequestsFriendshipIdDelete', 'friendshipId', friendshipId)
            const localVarPath = `/v1/friends/requests/{friendship_id}`
                .replace(`{${"friendship_id"}}`, encodeURIComponent(String(friendshipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 친구 여부 확인  특정 사용자와 친구인지 확인합니다.
         * @summary Check Friendship
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkFriendshipV1FriendsCheckUserIdGet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('checkFriendshipV1FriendsCheckUserIdGet', 'userId', userId)
            const localVarPath = `/v1/friends/check/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 친구 ID 목록만 조회 (효율적인 쿼리)  친구 목록을 빠르게 확인할 때 사용합니다.
         * @summary List Friend Ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFriendIdsV1FriendsIdsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/friends/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 친구 목록 조회  현재 사용자의 모든 친구 목록을 반환합니다.
         * @summary List Friends
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFriendsV1FriendsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/friends`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 받은 친구 요청 목록 조회  대기 중인 친구 요청만 반환합니다.
         * @summary List Received Requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReceivedRequestsV1FriendsRequestsReceivedGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/friends/requests/received`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 보낸 친구 요청 목록 조회  대기 중인 친구 요청만 반환합니다.
         * @summary List Sent Requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSentRequestsV1FriendsRequestsSentGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/friends/requests/sent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 친구 요청 거절  받은 친구 요청을 거절합니다. 거절된 요청은 삭제됩니다.
         * @summary Reject Friend Request
         * @param {string} friendshipId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectFriendRequestV1FriendsRequestsFriendshipIdRejectPost: async (friendshipId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'friendshipId' is not null or undefined
            assertParamExists('rejectFriendRequestV1FriendsRequestsFriendshipIdRejectPost', 'friendshipId', friendshipId)
            const localVarPath = `/v1/friends/requests/{friendship_id}/reject`
                .replace(`{${"friendship_id"}}`, encodeURIComponent(String(friendshipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 친구 삭제  친구 관계를 끊습니다. 양쪽 모두 삭제할 수 있습니다.
         * @summary Remove Friend
         * @param {string} friendshipId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFriendV1FriendsFriendshipIdDelete: async (friendshipId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'friendshipId' is not null or undefined
            assertParamExists('removeFriendV1FriendsFriendshipIdDelete', 'friendshipId', friendshipId)
            const localVarPath = `/v1/friends/{friendship_id}`
                .replace(`{${"friendship_id"}}`, encodeURIComponent(String(friendshipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 친구 요청 보내기  대상 사용자에게 친구 요청을 보냅니다. 이미 친구이거나 대기 중인 요청이 있으면 에러가 발생합니다.
         * @summary Send Friend Request
         * @param {FriendRequest} friendRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendFriendRequestV1FriendsRequestsPost: async (friendRequest: FriendRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'friendRequest' is not null or undefined
            assertParamExists('sendFriendRequestV1FriendsRequestsPost', 'friendRequest', friendRequest)
            const localVarPath = `/v1/friends/requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(friendRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 사용자 차단 해제  차단을 해제합니다. 본인이 차단한 경우에만 해제할 수 있습니다.
         * @summary Unblock User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unblockUserV1FriendsBlockUserIdDelete: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('unblockUserV1FriendsBlockUserIdDelete', 'userId', userId)
            const localVarPath = `/v1/friends/block/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FriendsApi - functional programming interface
 */
export const FriendsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FriendsApiAxiosParamCreator(configuration)
    return {
        /**
         * 친구 요청 수락  받은 친구 요청을 수락합니다. 요청 수신자만 수락할 수 있습니다.
         * @summary Accept Friend Request
         * @param {string} friendshipId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptFriendRequestV1FriendsRequestsFriendshipIdAcceptPost(friendshipId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FriendshipRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptFriendRequestV1FriendsRequestsFriendshipIdAcceptPost(friendshipId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FriendsApi.acceptFriendRequestV1FriendsRequestsFriendshipIdAcceptPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 사용자 차단  특정 사용자를 차단합니다. 차단된 사용자는 친구 요청을 보낼 수 없고, 공유된 콘텐츠에 접근할 수 없습니다.
         * @summary Block User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blockUserV1FriendsBlockUserIdPost(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FriendshipRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blockUserV1FriendsBlockUserIdPost(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FriendsApi.blockUserV1FriendsBlockUserIdPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 보낸 친구 요청 취소  보낸 친구 요청을 취소합니다. 요청 발신자만 취소할 수 있습니다.
         * @summary Cancel Friend Request
         * @param {string} friendshipId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelFriendRequestV1FriendsRequestsFriendshipIdDelete(friendshipId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelFriendRequestV1FriendsRequestsFriendshipIdDelete(friendshipId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FriendsApi.cancelFriendRequestV1FriendsRequestsFriendshipIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 친구 여부 확인  특정 사용자와 친구인지 확인합니다.
         * @summary Check Friendship
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkFriendshipV1FriendsCheckUserIdGet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkFriendshipV1FriendsCheckUserIdGet(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FriendsApi.checkFriendshipV1FriendsCheckUserIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 친구 ID 목록만 조회 (효율적인 쿼리)  친구 목록을 빠르게 확인할 때 사용합니다.
         * @summary List Friend Ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFriendIdsV1FriendsIdsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string | null>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFriendIdsV1FriendsIdsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FriendsApi.listFriendIdsV1FriendsIdsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 친구 목록 조회  현재 사용자의 모든 친구 목록을 반환합니다.
         * @summary List Friends
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFriendsV1FriendsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FriendRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFriendsV1FriendsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FriendsApi.listFriendsV1FriendsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 받은 친구 요청 목록 조회  대기 중인 친구 요청만 반환합니다.
         * @summary List Received Requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listReceivedRequestsV1FriendsRequestsReceivedGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PendingRequestRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listReceivedRequestsV1FriendsRequestsReceivedGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FriendsApi.listReceivedRequestsV1FriendsRequestsReceivedGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 보낸 친구 요청 목록 조회  대기 중인 친구 요청만 반환합니다.
         * @summary List Sent Requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSentRequestsV1FriendsRequestsSentGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PendingRequestRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSentRequestsV1FriendsRequestsSentGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FriendsApi.listSentRequestsV1FriendsRequestsSentGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 친구 요청 거절  받은 친구 요청을 거절합니다. 거절된 요청은 삭제됩니다.
         * @summary Reject Friend Request
         * @param {string} friendshipId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectFriendRequestV1FriendsRequestsFriendshipIdRejectPost(friendshipId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectFriendRequestV1FriendsRequestsFriendshipIdRejectPost(friendshipId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FriendsApi.rejectFriendRequestV1FriendsRequestsFriendshipIdRejectPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 친구 삭제  친구 관계를 끊습니다. 양쪽 모두 삭제할 수 있습니다.
         * @summary Remove Friend
         * @param {string} friendshipId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeFriendV1FriendsFriendshipIdDelete(friendshipId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeFriendV1FriendsFriendshipIdDelete(friendshipId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FriendsApi.removeFriendV1FriendsFriendshipIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 친구 요청 보내기  대상 사용자에게 친구 요청을 보냅니다. 이미 친구이거나 대기 중인 요청이 있으면 에러가 발생합니다.
         * @summary Send Friend Request
         * @param {FriendRequest} friendRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendFriendRequestV1FriendsRequestsPost(friendRequest: FriendRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FriendshipRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendFriendRequestV1FriendsRequestsPost(friendRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FriendsApi.sendFriendRequestV1FriendsRequestsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 사용자 차단 해제  차단을 해제합니다. 본인이 차단한 경우에만 해제할 수 있습니다.
         * @summary Unblock User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unblockUserV1FriendsBlockUserIdDelete(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unblockUserV1FriendsBlockUserIdDelete(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FriendsApi.unblockUserV1FriendsBlockUserIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FriendsApi - factory interface
 */
export const FriendsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FriendsApiFp(configuration)
    return {
        /**
         * 친구 요청 수락  받은 친구 요청을 수락합니다. 요청 수신자만 수락할 수 있습니다.
         * @summary Accept Friend Request
         * @param {string} friendshipId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptFriendRequestV1FriendsRequestsFriendshipIdAcceptPost(friendshipId: string, options?: RawAxiosRequestConfig): AxiosPromise<FriendshipRead> {
            return localVarFp.acceptFriendRequestV1FriendsRequestsFriendshipIdAcceptPost(friendshipId, options).then((request) => request(axios, basePath));
        },
        /**
         * 사용자 차단  특정 사용자를 차단합니다. 차단된 사용자는 친구 요청을 보낼 수 없고, 공유된 콘텐츠에 접근할 수 없습니다.
         * @summary Block User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockUserV1FriendsBlockUserIdPost(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<FriendshipRead> {
            return localVarFp.blockUserV1FriendsBlockUserIdPost(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 보낸 친구 요청 취소  보낸 친구 요청을 취소합니다. 요청 발신자만 취소할 수 있습니다.
         * @summary Cancel Friend Request
         * @param {string} friendshipId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelFriendRequestV1FriendsRequestsFriendshipIdDelete(friendshipId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.cancelFriendRequestV1FriendsRequestsFriendshipIdDelete(friendshipId, options).then((request) => request(axios, basePath));
        },
        /**
         * 친구 여부 확인  특정 사용자와 친구인지 확인합니다.
         * @summary Check Friendship
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkFriendshipV1FriendsCheckUserIdGet(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.checkFriendshipV1FriendsCheckUserIdGet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 친구 ID 목록만 조회 (효율적인 쿼리)  친구 목록을 빠르게 확인할 때 사용합니다.
         * @summary List Friend Ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFriendIdsV1FriendsIdsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<string | null>> {
            return localVarFp.listFriendIdsV1FriendsIdsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 친구 목록 조회  현재 사용자의 모든 친구 목록을 반환합니다.
         * @summary List Friends
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFriendsV1FriendsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<FriendRead>> {
            return localVarFp.listFriendsV1FriendsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 받은 친구 요청 목록 조회  대기 중인 친구 요청만 반환합니다.
         * @summary List Received Requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReceivedRequestsV1FriendsRequestsReceivedGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<PendingRequestRead>> {
            return localVarFp.listReceivedRequestsV1FriendsRequestsReceivedGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 보낸 친구 요청 목록 조회  대기 중인 친구 요청만 반환합니다.
         * @summary List Sent Requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSentRequestsV1FriendsRequestsSentGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<PendingRequestRead>> {
            return localVarFp.listSentRequestsV1FriendsRequestsSentGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 친구 요청 거절  받은 친구 요청을 거절합니다. 거절된 요청은 삭제됩니다.
         * @summary Reject Friend Request
         * @param {string} friendshipId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectFriendRequestV1FriendsRequestsFriendshipIdRejectPost(friendshipId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.rejectFriendRequestV1FriendsRequestsFriendshipIdRejectPost(friendshipId, options).then((request) => request(axios, basePath));
        },
        /**
         * 친구 삭제  친구 관계를 끊습니다. 양쪽 모두 삭제할 수 있습니다.
         * @summary Remove Friend
         * @param {string} friendshipId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFriendV1FriendsFriendshipIdDelete(friendshipId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.removeFriendV1FriendsFriendshipIdDelete(friendshipId, options).then((request) => request(axios, basePath));
        },
        /**
         * 친구 요청 보내기  대상 사용자에게 친구 요청을 보냅니다. 이미 친구이거나 대기 중인 요청이 있으면 에러가 발생합니다.
         * @summary Send Friend Request
         * @param {FriendRequest} friendRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendFriendRequestV1FriendsRequestsPost(friendRequest: FriendRequest, options?: RawAxiosRequestConfig): AxiosPromise<FriendshipRead> {
            return localVarFp.sendFriendRequestV1FriendsRequestsPost(friendRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 사용자 차단 해제  차단을 해제합니다. 본인이 차단한 경우에만 해제할 수 있습니다.
         * @summary Unblock User
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unblockUserV1FriendsBlockUserIdDelete(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.unblockUserV1FriendsBlockUserIdDelete(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FriendsApi - object-oriented interface
 */
export class FriendsApi extends BaseAPI {
    /**
     * 친구 요청 수락  받은 친구 요청을 수락합니다. 요청 수신자만 수락할 수 있습니다.
     * @summary Accept Friend Request
     * @param {string} friendshipId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public acceptFriendRequestV1FriendsRequestsFriendshipIdAcceptPost(friendshipId: string, options?: RawAxiosRequestConfig) {
        return FriendsApiFp(this.configuration).acceptFriendRequestV1FriendsRequestsFriendshipIdAcceptPost(friendshipId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 사용자 차단  특정 사용자를 차단합니다. 차단된 사용자는 친구 요청을 보낼 수 없고, 공유된 콘텐츠에 접근할 수 없습니다.
     * @summary Block User
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public blockUserV1FriendsBlockUserIdPost(userId: string, options?: RawAxiosRequestConfig) {
        return FriendsApiFp(this.configuration).blockUserV1FriendsBlockUserIdPost(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 보낸 친구 요청 취소  보낸 친구 요청을 취소합니다. 요청 발신자만 취소할 수 있습니다.
     * @summary Cancel Friend Request
     * @param {string} friendshipId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cancelFriendRequestV1FriendsRequestsFriendshipIdDelete(friendshipId: string, options?: RawAxiosRequestConfig) {
        return FriendsApiFp(this.configuration).cancelFriendRequestV1FriendsRequestsFriendshipIdDelete(friendshipId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 친구 여부 확인  특정 사용자와 친구인지 확인합니다.
     * @summary Check Friendship
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public checkFriendshipV1FriendsCheckUserIdGet(userId: string, options?: RawAxiosRequestConfig) {
        return FriendsApiFp(this.configuration).checkFriendshipV1FriendsCheckUserIdGet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 친구 ID 목록만 조회 (효율적인 쿼리)  친구 목록을 빠르게 확인할 때 사용합니다.
     * @summary List Friend Ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listFriendIdsV1FriendsIdsGet(options?: RawAxiosRequestConfig) {
        return FriendsApiFp(this.configuration).listFriendIdsV1FriendsIdsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 친구 목록 조회  현재 사용자의 모든 친구 목록을 반환합니다.
     * @summary List Friends
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listFriendsV1FriendsGet(options?: RawAxiosRequestConfig) {
        return FriendsApiFp(this.configuration).listFriendsV1FriendsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 받은 친구 요청 목록 조회  대기 중인 친구 요청만 반환합니다.
     * @summary List Received Requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listReceivedRequestsV1FriendsRequestsReceivedGet(options?: RawAxiosRequestConfig) {
        return FriendsApiFp(this.configuration).listReceivedRequestsV1FriendsRequestsReceivedGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 보낸 친구 요청 목록 조회  대기 중인 친구 요청만 반환합니다.
     * @summary List Sent Requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listSentRequestsV1FriendsRequestsSentGet(options?: RawAxiosRequestConfig) {
        return FriendsApiFp(this.configuration).listSentRequestsV1FriendsRequestsSentGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 친구 요청 거절  받은 친구 요청을 거절합니다. 거절된 요청은 삭제됩니다.
     * @summary Reject Friend Request
     * @param {string} friendshipId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rejectFriendRequestV1FriendsRequestsFriendshipIdRejectPost(friendshipId: string, options?: RawAxiosRequestConfig) {
        return FriendsApiFp(this.configuration).rejectFriendRequestV1FriendsRequestsFriendshipIdRejectPost(friendshipId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 친구 삭제  친구 관계를 끊습니다. 양쪽 모두 삭제할 수 있습니다.
     * @summary Remove Friend
     * @param {string} friendshipId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public removeFriendV1FriendsFriendshipIdDelete(friendshipId: string, options?: RawAxiosRequestConfig) {
        return FriendsApiFp(this.configuration).removeFriendV1FriendsFriendshipIdDelete(friendshipId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 친구 요청 보내기  대상 사용자에게 친구 요청을 보냅니다. 이미 친구이거나 대기 중인 요청이 있으면 에러가 발생합니다.
     * @summary Send Friend Request
     * @param {FriendRequest} friendRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public sendFriendRequestV1FriendsRequestsPost(friendRequest: FriendRequest, options?: RawAxiosRequestConfig) {
        return FriendsApiFp(this.configuration).sendFriendRequestV1FriendsRequestsPost(friendRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 사용자 차단 해제  차단을 해제합니다. 본인이 차단한 경우에만 해제할 수 있습니다.
     * @summary Unblock User
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public unblockUserV1FriendsBlockUserIdDelete(userId: string, options?: RawAxiosRequestConfig) {
        return FriendsApiFp(this.configuration).unblockUserV1FriendsBlockUserIdDelete(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GraphQLApi - axios parameter creator
 */
export const GraphQLApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Handle Http Get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleHttpGetV1GraphqlGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/graphql`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Handle Http Post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleHttpPostV1GraphqlPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/graphql`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GraphQLApi - functional programming interface
 */
export const GraphQLApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GraphQLApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Handle Http Get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleHttpGetV1GraphqlGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleHttpGetV1GraphqlGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GraphQLApi.handleHttpGetV1GraphqlGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Handle Http Post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleHttpPostV1GraphqlPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleHttpPostV1GraphqlPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GraphQLApi.handleHttpPostV1GraphqlPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GraphQLApi - factory interface
 */
export const GraphQLApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GraphQLApiFp(configuration)
    return {
        /**
         * 
         * @summary Handle Http Get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleHttpGetV1GraphqlGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.handleHttpGetV1GraphqlGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Handle Http Post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleHttpPostV1GraphqlPost(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.handleHttpPostV1GraphqlPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GraphQLApi - object-oriented interface
 */
export class GraphQLApi extends BaseAPI {
    /**
     * 
     * @summary Handle Http Get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public handleHttpGetV1GraphqlGet(options?: RawAxiosRequestConfig) {
        return GraphQLApiFp(this.configuration).handleHttpGetV1GraphqlGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Handle Http Post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public handleHttpPostV1GraphqlPost(options?: RawAxiosRequestConfig) {
        return GraphQLApiFp(this.configuration).handleHttpPostV1GraphqlPost(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HealthApi - axios parameter creator
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 애플리케이션 상태 확인  로드밸런서, Kubernetes, ECS 등에서 사용하는 health check 엔드포인트. 인증 없이 접근 가능합니다.
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheckHealthGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * 애플리케이션 상태 확인  로드밸런서, Kubernetes, ECS 등에서 사용하는 health check 엔드포인트. 인증 없이 접근 가능합니다.
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthCheckHealthGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthCheckHealthGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.healthCheckHealthGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthApi - factory interface
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * 애플리케이션 상태 확인  로드밸런서, Kubernetes, ECS 등에서 사용하는 health check 엔드포인트. 인증 없이 접근 가능합니다.
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheckHealthGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.healthCheckHealthGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 */
export class HealthApi extends BaseAPI {
    /**
     * 애플리케이션 상태 확인  로드밸런서, Kubernetes, ECS 등에서 사용하는 health check 엔드포인트. 인증 없이 접근 가능합니다.
     * @summary Health Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public healthCheckHealthGet(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).healthCheckHealthGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HolidaysApi - axios parameter creator
 */
export const HolidaysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 공휴일 조회  - year만 지정: 해당 연도 조회 - start_year/end_year 지정: 범위 조회 (end_year 없으면 start_year로 대체) - 미지정: 현재 연도 조회 - auto_sync=False (기본값): DB에 있는 데이터만 반환 - auto_sync=True: 데이터가 없으면 자동으로 동기화 수행 후 결과 반환 - 422 에러: 해당 연도의 공휴일 데이터가 준비되지 않은 경우 (2028년 이후 등)
         * @summary Get Holidays
         * @param {number | null} [year] 조회 연도 (YYYY)
         * @param {number | null} [startYear] 시작 연도 (YYYY)
         * @param {number | null} [endYear] 종료 연도 (YYYY)
         * @param {boolean} [autoSync] 데이터가 없을 경우 자동으로 동기화 실행
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHolidaysV1HolidaysGet: async (year?: number | null, startYear?: number | null, endYear?: number | null, autoSync?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/holidays`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }

            if (startYear !== undefined) {
                localVarQueryParameter['start_year'] = startYear;
            }

            if (endYear !== undefined) {
                localVarQueryParameter['end_year'] = endYear;
            }

            if (autoSync !== undefined) {
                localVarQueryParameter['auto_sync'] = autoSync;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HolidaysApi - functional programming interface
 */
export const HolidaysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HolidaysApiAxiosParamCreator(configuration)
    return {
        /**
         * 공휴일 조회  - year만 지정: 해당 연도 조회 - start_year/end_year 지정: 범위 조회 (end_year 없으면 start_year로 대체) - 미지정: 현재 연도 조회 - auto_sync=False (기본값): DB에 있는 데이터만 반환 - auto_sync=True: 데이터가 없으면 자동으로 동기화 수행 후 결과 반환 - 422 에러: 해당 연도의 공휴일 데이터가 준비되지 않은 경우 (2028년 이후 등)
         * @summary Get Holidays
         * @param {number | null} [year] 조회 연도 (YYYY)
         * @param {number | null} [startYear] 시작 연도 (YYYY)
         * @param {number | null} [endYear] 종료 연도 (YYYY)
         * @param {boolean} [autoSync] 데이터가 없을 경우 자동으로 동기화 실행
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHolidaysV1HolidaysGet(year?: number | null, startYear?: number | null, endYear?: number | null, autoSync?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<HolidayItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHolidaysV1HolidaysGet(year, startYear, endYear, autoSync, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HolidaysApi.getHolidaysV1HolidaysGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HolidaysApi - factory interface
 */
export const HolidaysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HolidaysApiFp(configuration)
    return {
        /**
         * 공휴일 조회  - year만 지정: 해당 연도 조회 - start_year/end_year 지정: 범위 조회 (end_year 없으면 start_year로 대체) - 미지정: 현재 연도 조회 - auto_sync=False (기본값): DB에 있는 데이터만 반환 - auto_sync=True: 데이터가 없으면 자동으로 동기화 수행 후 결과 반환 - 422 에러: 해당 연도의 공휴일 데이터가 준비되지 않은 경우 (2028년 이후 등)
         * @summary Get Holidays
         * @param {number | null} [year] 조회 연도 (YYYY)
         * @param {number | null} [startYear] 시작 연도 (YYYY)
         * @param {number | null} [endYear] 종료 연도 (YYYY)
         * @param {boolean} [autoSync] 데이터가 없을 경우 자동으로 동기화 실행
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHolidaysV1HolidaysGet(year?: number | null, startYear?: number | null, endYear?: number | null, autoSync?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<HolidayItem>> {
            return localVarFp.getHolidaysV1HolidaysGet(year, startYear, endYear, autoSync, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HolidaysApi - object-oriented interface
 */
export class HolidaysApi extends BaseAPI {
    /**
     * 공휴일 조회  - year만 지정: 해당 연도 조회 - start_year/end_year 지정: 범위 조회 (end_year 없으면 start_year로 대체) - 미지정: 현재 연도 조회 - auto_sync=False (기본값): DB에 있는 데이터만 반환 - auto_sync=True: 데이터가 없으면 자동으로 동기화 수행 후 결과 반환 - 422 에러: 해당 연도의 공휴일 데이터가 준비되지 않은 경우 (2028년 이후 등)
     * @summary Get Holidays
     * @param {number | null} [year] 조회 연도 (YYYY)
     * @param {number | null} [startYear] 시작 연도 (YYYY)
     * @param {number | null} [endYear] 종료 연도 (YYYY)
     * @param {boolean} [autoSync] 데이터가 없을 경우 자동으로 동기화 실행
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getHolidaysV1HolidaysGet(year?: number | null, startYear?: number | null, endYear?: number | null, autoSync?: boolean, options?: RawAxiosRequestConfig) {
        return HolidaysApiFp(this.configuration).getHolidaysV1HolidaysGet(year, startYear, endYear, autoSync, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MeetingsApi - axios parameter creator
 */
export const MeetingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 일정 조율 생성  인증 필수: 일정 조율 생성자는 소유자가 됩니다.
         * @summary Create Meeting
         * @param {MeetingCreate} meetingCreate 
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMeetingV1MeetingsPost: async (meetingCreate: MeetingCreate, timezone?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'meetingCreate' is not null or undefined
            assertParamExists('createMeetingV1MeetingsPost', 'meetingCreate', meetingCreate)
            const localVarPath = `/v1/meetings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(meetingCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 참여자 등록  인증 필수: 접근 권한이 있는 사용자만 참여 가능합니다.
         * @summary Create Participant
         * @param {string} meetingId 
         * @param {ParticipantCreate} participantCreate 
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createParticipantV1MeetingsMeetingIdParticipatePost: async (meetingId: string, participantCreate: ParticipantCreate, timezone?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'meetingId' is not null or undefined
            assertParamExists('createParticipantV1MeetingsMeetingIdParticipatePost', 'meetingId', meetingId)
            // verify required parameter 'participantCreate' is not null or undefined
            assertParamExists('createParticipantV1MeetingsMeetingIdParticipatePost', 'participantCreate', participantCreate)
            const localVarPath = `/v1/meetings/{meeting_id}/participate`
                .replace(`{${"meeting_id"}}`, encodeURIComponent(String(meetingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(participantCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 일정 조율 삭제  인증 필수: 소유자만 삭제 가능합니다.
         * @summary Delete Meeting
         * @param {string} meetingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMeetingV1MeetingsMeetingIdDelete: async (meetingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'meetingId' is not null or undefined
            assertParamExists('deleteMeetingV1MeetingsMeetingIdDelete', 'meetingId', meetingId)
            const localVarPath = `/v1/meetings/{meeting_id}`
                .replace(`{${"meeting_id"}}`, encodeURIComponent(String(meetingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 전체 참여자의 가능 시간 조회  인증 선택적: 접근 권한이 있는 경우 조회 가능합니다.
         * @summary Get Availability
         * @param {string} meetingId 
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailabilityV1MeetingsMeetingIdAvailabilityGet: async (meetingId: string, timezone?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'meetingId' is not null or undefined
            assertParamExists('getAvailabilityV1MeetingsMeetingIdAvailabilityGet', 'meetingId', meetingId)
            const localVarPath = `/v1/meetings/{meeting_id}/availability`
                .replace(`{${"meeting_id"}}`, encodeURIComponent(String(meetingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 공통 가능 시간 분석 결과 조회  인증 선택적: 접근 권한이 있는 경우 조회 가능합니다. 모든 참여자의 시간 선택을 집계하여 겹치는 시간대와 인원 수를 계산합니다.
         * @summary Get Meeting Result
         * @param {string} meetingId 
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMeetingResultV1MeetingsMeetingIdResultGet: async (meetingId: string, timezone?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'meetingId' is not null or undefined
            assertParamExists('getMeetingResultV1MeetingsMeetingIdResultGet', 'meetingId', meetingId)
            const localVarPath = `/v1/meetings/{meeting_id}/result`
                .replace(`{${"meeting_id"}}`, encodeURIComponent(String(meetingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 일정 조율 상세 조회  인증 선택적: 접근 권한이 있는 경우 조회 가능합니다. - PUBLIC: 인증 없이도 조회 가능 (현재는 인증 필수로 처리) - ALLOWED_EMAILS: 허용된 이메일 사용자만 조회 가능 (인증 필수)  Note: PUBLIC 레벨의 비인증 접근은 추후 구현 예정
         * @summary Read Meeting
         * @param {string} meetingId 
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readMeetingV1MeetingsMeetingIdGet: async (meetingId: string, timezone?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'meetingId' is not null or undefined
            assertParamExists('readMeetingV1MeetingsMeetingIdGet', 'meetingId', meetingId)
            const localVarPath = `/v1/meetings/{meeting_id}`
                .replace(`{${"meeting_id"}}`, encodeURIComponent(String(meetingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 내가 생성한 일정 조율 목록 조회  인증 필수: 본인이 생성한 일정 조율만 조회됩니다.
         * @summary Read Meetings
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readMeetingsV1MeetingsGet: async (timezone?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/meetings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 참여자의 가능 시간 설정  인증 필수: 본인의 참여 시간만 설정 가능합니다. 기존 시간 슬롯을 모두 삭제하고 새로운 시간 슬롯을 설정합니다.  :param meeting_id: 일정 조율 ID :param participant_id: 참여자 ID (쿼리 파라미터) :param time_slots: 시간 슬롯 리스트 (요청 본문)
         * @summary Set Availability
         * @param {string} meetingId 
         * @param {string} participantId 참여자 ID
         * @param {Array<TimeSlotCreate>} timeSlotCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAvailabilityV1MeetingsMeetingIdAvailabilityPut: async (meetingId: string, participantId: string, timeSlotCreate: Array<TimeSlotCreate>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'meetingId' is not null or undefined
            assertParamExists('setAvailabilityV1MeetingsMeetingIdAvailabilityPut', 'meetingId', meetingId)
            // verify required parameter 'participantId' is not null or undefined
            assertParamExists('setAvailabilityV1MeetingsMeetingIdAvailabilityPut', 'participantId', participantId)
            // verify required parameter 'timeSlotCreate' is not null or undefined
            assertParamExists('setAvailabilityV1MeetingsMeetingIdAvailabilityPut', 'timeSlotCreate', timeSlotCreate)
            const localVarPath = `/v1/meetings/{meeting_id}/availability`
                .replace(`{${"meeting_id"}}`, encodeURIComponent(String(meetingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (participantId !== undefined) {
                localVarQueryParameter['participant_id'] = participantId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(timeSlotCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 일정 조율 수정  인증 필수: 소유자만 수정 가능합니다.
         * @summary Update Meeting
         * @param {string} meetingId 
         * @param {MeetingUpdate} meetingUpdate 
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMeetingV1MeetingsMeetingIdPatch: async (meetingId: string, meetingUpdate: MeetingUpdate, timezone?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'meetingId' is not null or undefined
            assertParamExists('updateMeetingV1MeetingsMeetingIdPatch', 'meetingId', meetingId)
            // verify required parameter 'meetingUpdate' is not null or undefined
            assertParamExists('updateMeetingV1MeetingsMeetingIdPatch', 'meetingUpdate', meetingUpdate)
            const localVarPath = `/v1/meetings/{meeting_id}`
                .replace(`{${"meeting_id"}}`, encodeURIComponent(String(meetingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(meetingUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeetingsApi - functional programming interface
 */
export const MeetingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MeetingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 일정 조율 생성  인증 필수: 일정 조율 생성자는 소유자가 됩니다.
         * @summary Create Meeting
         * @param {MeetingCreate} meetingCreate 
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMeetingV1MeetingsPost(meetingCreate: MeetingCreate, timezone?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeetingRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMeetingV1MeetingsPost(meetingCreate, timezone, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeetingsApi.createMeetingV1MeetingsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 참여자 등록  인증 필수: 접근 권한이 있는 사용자만 참여 가능합니다.
         * @summary Create Participant
         * @param {string} meetingId 
         * @param {ParticipantCreate} participantCreate 
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createParticipantV1MeetingsMeetingIdParticipatePost(meetingId: string, participantCreate: ParticipantCreate, timezone?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParticipantRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createParticipantV1MeetingsMeetingIdParticipatePost(meetingId, participantCreate, timezone, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeetingsApi.createParticipantV1MeetingsMeetingIdParticipatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 일정 조율 삭제  인증 필수: 소유자만 삭제 가능합니다.
         * @summary Delete Meeting
         * @param {string} meetingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMeetingV1MeetingsMeetingIdDelete(meetingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMeetingV1MeetingsMeetingIdDelete(meetingId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeetingsApi.deleteMeetingV1MeetingsMeetingIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 전체 참여자의 가능 시간 조회  인증 선택적: 접근 권한이 있는 경우 조회 가능합니다.
         * @summary Get Availability
         * @param {string} meetingId 
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailabilityV1MeetingsMeetingIdAvailabilityGet(meetingId: string, timezone?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AvailabilityRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvailabilityV1MeetingsMeetingIdAvailabilityGet(meetingId, timezone, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeetingsApi.getAvailabilityV1MeetingsMeetingIdAvailabilityGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 공통 가능 시간 분석 결과 조회  인증 선택적: 접근 권한이 있는 경우 조회 가능합니다. 모든 참여자의 시간 선택을 집계하여 겹치는 시간대와 인원 수를 계산합니다.
         * @summary Get Meeting Result
         * @param {string} meetingId 
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMeetingResultV1MeetingsMeetingIdResultGet(meetingId: string, timezone?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeetingResultRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMeetingResultV1MeetingsMeetingIdResultGet(meetingId, timezone, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeetingsApi.getMeetingResultV1MeetingsMeetingIdResultGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 일정 조율 상세 조회  인증 선택적: 접근 권한이 있는 경우 조회 가능합니다. - PUBLIC: 인증 없이도 조회 가능 (현재는 인증 필수로 처리) - ALLOWED_EMAILS: 허용된 이메일 사용자만 조회 가능 (인증 필수)  Note: PUBLIC 레벨의 비인증 접근은 추후 구현 예정
         * @summary Read Meeting
         * @param {string} meetingId 
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readMeetingV1MeetingsMeetingIdGet(meetingId: string, timezone?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeetingRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readMeetingV1MeetingsMeetingIdGet(meetingId, timezone, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeetingsApi.readMeetingV1MeetingsMeetingIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 내가 생성한 일정 조율 목록 조회  인증 필수: 본인이 생성한 일정 조율만 조회됩니다.
         * @summary Read Meetings
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readMeetingsV1MeetingsGet(timezone?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MeetingRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readMeetingsV1MeetingsGet(timezone, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeetingsApi.readMeetingsV1MeetingsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 참여자의 가능 시간 설정  인증 필수: 본인의 참여 시간만 설정 가능합니다. 기존 시간 슬롯을 모두 삭제하고 새로운 시간 슬롯을 설정합니다.  :param meeting_id: 일정 조율 ID :param participant_id: 참여자 ID (쿼리 파라미터) :param time_slots: 시간 슬롯 리스트 (요청 본문)
         * @summary Set Availability
         * @param {string} meetingId 
         * @param {string} participantId 참여자 ID
         * @param {Array<TimeSlotCreate>} timeSlotCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setAvailabilityV1MeetingsMeetingIdAvailabilityPut(meetingId: string, participantId: string, timeSlotCreate: Array<TimeSlotCreate>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TimeSlotRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setAvailabilityV1MeetingsMeetingIdAvailabilityPut(meetingId, participantId, timeSlotCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeetingsApi.setAvailabilityV1MeetingsMeetingIdAvailabilityPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 일정 조율 수정  인증 필수: 소유자만 수정 가능합니다.
         * @summary Update Meeting
         * @param {string} meetingId 
         * @param {MeetingUpdate} meetingUpdate 
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMeetingV1MeetingsMeetingIdPatch(meetingId: string, meetingUpdate: MeetingUpdate, timezone?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeetingRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMeetingV1MeetingsMeetingIdPatch(meetingId, meetingUpdate, timezone, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeetingsApi.updateMeetingV1MeetingsMeetingIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MeetingsApi - factory interface
 */
export const MeetingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MeetingsApiFp(configuration)
    return {
        /**
         * 일정 조율 생성  인증 필수: 일정 조율 생성자는 소유자가 됩니다.
         * @summary Create Meeting
         * @param {MeetingCreate} meetingCreate 
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMeetingV1MeetingsPost(meetingCreate: MeetingCreate, timezone?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<MeetingRead> {
            return localVarFp.createMeetingV1MeetingsPost(meetingCreate, timezone, options).then((request) => request(axios, basePath));
        },
        /**
         * 참여자 등록  인증 필수: 접근 권한이 있는 사용자만 참여 가능합니다.
         * @summary Create Participant
         * @param {string} meetingId 
         * @param {ParticipantCreate} participantCreate 
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createParticipantV1MeetingsMeetingIdParticipatePost(meetingId: string, participantCreate: ParticipantCreate, timezone?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<ParticipantRead> {
            return localVarFp.createParticipantV1MeetingsMeetingIdParticipatePost(meetingId, participantCreate, timezone, options).then((request) => request(axios, basePath));
        },
        /**
         * 일정 조율 삭제  인증 필수: 소유자만 삭제 가능합니다.
         * @summary Delete Meeting
         * @param {string} meetingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMeetingV1MeetingsMeetingIdDelete(meetingId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.deleteMeetingV1MeetingsMeetingIdDelete(meetingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 전체 참여자의 가능 시간 조회  인증 선택적: 접근 권한이 있는 경우 조회 가능합니다.
         * @summary Get Availability
         * @param {string} meetingId 
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailabilityV1MeetingsMeetingIdAvailabilityGet(meetingId: string, timezone?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<AvailabilityRead>> {
            return localVarFp.getAvailabilityV1MeetingsMeetingIdAvailabilityGet(meetingId, timezone, options).then((request) => request(axios, basePath));
        },
        /**
         * 공통 가능 시간 분석 결과 조회  인증 선택적: 접근 권한이 있는 경우 조회 가능합니다. 모든 참여자의 시간 선택을 집계하여 겹치는 시간대와 인원 수를 계산합니다.
         * @summary Get Meeting Result
         * @param {string} meetingId 
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMeetingResultV1MeetingsMeetingIdResultGet(meetingId: string, timezone?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<MeetingResultRead> {
            return localVarFp.getMeetingResultV1MeetingsMeetingIdResultGet(meetingId, timezone, options).then((request) => request(axios, basePath));
        },
        /**
         * 일정 조율 상세 조회  인증 선택적: 접근 권한이 있는 경우 조회 가능합니다. - PUBLIC: 인증 없이도 조회 가능 (현재는 인증 필수로 처리) - ALLOWED_EMAILS: 허용된 이메일 사용자만 조회 가능 (인증 필수)  Note: PUBLIC 레벨의 비인증 접근은 추후 구현 예정
         * @summary Read Meeting
         * @param {string} meetingId 
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readMeetingV1MeetingsMeetingIdGet(meetingId: string, timezone?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<MeetingRead> {
            return localVarFp.readMeetingV1MeetingsMeetingIdGet(meetingId, timezone, options).then((request) => request(axios, basePath));
        },
        /**
         * 내가 생성한 일정 조율 목록 조회  인증 필수: 본인이 생성한 일정 조율만 조회됩니다.
         * @summary Read Meetings
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readMeetingsV1MeetingsGet(timezone?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<MeetingRead>> {
            return localVarFp.readMeetingsV1MeetingsGet(timezone, options).then((request) => request(axios, basePath));
        },
        /**
         * 참여자의 가능 시간 설정  인증 필수: 본인의 참여 시간만 설정 가능합니다. 기존 시간 슬롯을 모두 삭제하고 새로운 시간 슬롯을 설정합니다.  :param meeting_id: 일정 조율 ID :param participant_id: 참여자 ID (쿼리 파라미터) :param time_slots: 시간 슬롯 리스트 (요청 본문)
         * @summary Set Availability
         * @param {string} meetingId 
         * @param {string} participantId 참여자 ID
         * @param {Array<TimeSlotCreate>} timeSlotCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAvailabilityV1MeetingsMeetingIdAvailabilityPut(meetingId: string, participantId: string, timeSlotCreate: Array<TimeSlotCreate>, options?: RawAxiosRequestConfig): AxiosPromise<Array<TimeSlotRead>> {
            return localVarFp.setAvailabilityV1MeetingsMeetingIdAvailabilityPut(meetingId, participantId, timeSlotCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 일정 조율 수정  인증 필수: 소유자만 수정 가능합니다.
         * @summary Update Meeting
         * @param {string} meetingId 
         * @param {MeetingUpdate} meetingUpdate 
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMeetingV1MeetingsMeetingIdPatch(meetingId: string, meetingUpdate: MeetingUpdate, timezone?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<MeetingRead> {
            return localVarFp.updateMeetingV1MeetingsMeetingIdPatch(meetingId, meetingUpdate, timezone, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MeetingsApi - object-oriented interface
 */
export class MeetingsApi extends BaseAPI {
    /**
     * 일정 조율 생성  인증 필수: 일정 조율 생성자는 소유자가 됩니다.
     * @summary Create Meeting
     * @param {MeetingCreate} meetingCreate 
     * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createMeetingV1MeetingsPost(meetingCreate: MeetingCreate, timezone?: string | null, options?: RawAxiosRequestConfig) {
        return MeetingsApiFp(this.configuration).createMeetingV1MeetingsPost(meetingCreate, timezone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 참여자 등록  인증 필수: 접근 권한이 있는 사용자만 참여 가능합니다.
     * @summary Create Participant
     * @param {string} meetingId 
     * @param {ParticipantCreate} participantCreate 
     * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createParticipantV1MeetingsMeetingIdParticipatePost(meetingId: string, participantCreate: ParticipantCreate, timezone?: string | null, options?: RawAxiosRequestConfig) {
        return MeetingsApiFp(this.configuration).createParticipantV1MeetingsMeetingIdParticipatePost(meetingId, participantCreate, timezone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 일정 조율 삭제  인증 필수: 소유자만 삭제 가능합니다.
     * @summary Delete Meeting
     * @param {string} meetingId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteMeetingV1MeetingsMeetingIdDelete(meetingId: string, options?: RawAxiosRequestConfig) {
        return MeetingsApiFp(this.configuration).deleteMeetingV1MeetingsMeetingIdDelete(meetingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 전체 참여자의 가능 시간 조회  인증 선택적: 접근 권한이 있는 경우 조회 가능합니다.
     * @summary Get Availability
     * @param {string} meetingId 
     * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAvailabilityV1MeetingsMeetingIdAvailabilityGet(meetingId: string, timezone?: string | null, options?: RawAxiosRequestConfig) {
        return MeetingsApiFp(this.configuration).getAvailabilityV1MeetingsMeetingIdAvailabilityGet(meetingId, timezone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 공통 가능 시간 분석 결과 조회  인증 선택적: 접근 권한이 있는 경우 조회 가능합니다. 모든 참여자의 시간 선택을 집계하여 겹치는 시간대와 인원 수를 계산합니다.
     * @summary Get Meeting Result
     * @param {string} meetingId 
     * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMeetingResultV1MeetingsMeetingIdResultGet(meetingId: string, timezone?: string | null, options?: RawAxiosRequestConfig) {
        return MeetingsApiFp(this.configuration).getMeetingResultV1MeetingsMeetingIdResultGet(meetingId, timezone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 일정 조율 상세 조회  인증 선택적: 접근 권한이 있는 경우 조회 가능합니다. - PUBLIC: 인증 없이도 조회 가능 (현재는 인증 필수로 처리) - ALLOWED_EMAILS: 허용된 이메일 사용자만 조회 가능 (인증 필수)  Note: PUBLIC 레벨의 비인증 접근은 추후 구현 예정
     * @summary Read Meeting
     * @param {string} meetingId 
     * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public readMeetingV1MeetingsMeetingIdGet(meetingId: string, timezone?: string | null, options?: RawAxiosRequestConfig) {
        return MeetingsApiFp(this.configuration).readMeetingV1MeetingsMeetingIdGet(meetingId, timezone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 내가 생성한 일정 조율 목록 조회  인증 필수: 본인이 생성한 일정 조율만 조회됩니다.
     * @summary Read Meetings
     * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public readMeetingsV1MeetingsGet(timezone?: string | null, options?: RawAxiosRequestConfig) {
        return MeetingsApiFp(this.configuration).readMeetingsV1MeetingsGet(timezone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 참여자의 가능 시간 설정  인증 필수: 본인의 참여 시간만 설정 가능합니다. 기존 시간 슬롯을 모두 삭제하고 새로운 시간 슬롯을 설정합니다.  :param meeting_id: 일정 조율 ID :param participant_id: 참여자 ID (쿼리 파라미터) :param time_slots: 시간 슬롯 리스트 (요청 본문)
     * @summary Set Availability
     * @param {string} meetingId 
     * @param {string} participantId 참여자 ID
     * @param {Array<TimeSlotCreate>} timeSlotCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public setAvailabilityV1MeetingsMeetingIdAvailabilityPut(meetingId: string, participantId: string, timeSlotCreate: Array<TimeSlotCreate>, options?: RawAxiosRequestConfig) {
        return MeetingsApiFp(this.configuration).setAvailabilityV1MeetingsMeetingIdAvailabilityPut(meetingId, participantId, timeSlotCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 일정 조율 수정  인증 필수: 소유자만 수정 가능합니다.
     * @summary Update Meeting
     * @param {string} meetingId 
     * @param {MeetingUpdate} meetingUpdate 
     * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateMeetingV1MeetingsMeetingIdPatch(meetingId: string, meetingUpdate: MeetingUpdate, timezone?: string | null, options?: RawAxiosRequestConfig) {
        return MeetingsApiFp(this.configuration).updateMeetingV1MeetingsMeetingIdPatch(meetingId, meetingUpdate, timezone, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SchedulesApi - axios parameter creator
 */
export const SchedulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 새 일정 생성  FastAPI Best Practices: - async 라우트 사용 - 트랜잭션 자동 관리 (context manager) - Exception Handler가 예외 처리
         * @summary Create Schedule
         * @param {ScheduleCreate} scheduleCreate 
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScheduleV1SchedulesPost: async (scheduleCreate: ScheduleCreate, timezone?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleCreate' is not null or undefined
            assertParamExists('createScheduleV1SchedulesPost', 'scheduleCreate', scheduleCreate)
            const localVarPath = `/v1/schedules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scheduleCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 기존 Schedule에서 연관된 Todo 생성  Schedule의 정보를 기반으로 새로운 Todo를 생성합니다: - Todo의 title, description은 Schedule에서 복사 - Todo의 deadline은 Schedule의 start_time으로 설정 - Schedule의 태그가 Todo에도 복사됨 - 생성된 Todo와 Schedule이 source_todo_id로 연결됨  제약사항: - 이미 Todo와 연결된 Schedule에서는 호출 불가 (400 에러) - tag_group_id는 필수 파라미터  :param schedule_id: Schedule ID :param tag_group_id: Todo가 속할 TagGroup ID :return: 생성된 Todo
         * @summary Create Todo From Schedule
         * @param {string} scheduleId 
         * @param {string} tagGroupId Todo가 속할 TagGroup ID (필수)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTodoFromScheduleV1SchedulesScheduleIdTodoPost: async (scheduleId: string, tagGroupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('createTodoFromScheduleV1SchedulesScheduleIdTodoPost', 'scheduleId', scheduleId)
            // verify required parameter 'tagGroupId' is not null or undefined
            assertParamExists('createTodoFromScheduleV1SchedulesScheduleIdTodoPost', 'tagGroupId', tagGroupId)
            const localVarPath = `/v1/schedules/{schedule_id}/todo`
                .replace(`{${"schedule_id"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (tagGroupId !== undefined) {
                localVarQueryParameter['tag_group_id'] = tagGroupId;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 일정 삭제 (반복 일정 인스턴스 포함)  일반 일정과 가상 인스턴스 모두 지원: - 일반 일정: schedule_id로 조회하여 삭제 - 가상 인스턴스: schedule_id를 parent_id로 사용하고 instance_start를 쿼리 파라미터로 전송  FastAPI Best Practices: - Service는 session을 받아서 CRUD 직접 사용 - 가상 인스턴스인 경우 instance_start 쿼리 파라미터로 처리
         * @summary Delete Schedule
         * @param {string} scheduleId 
         * @param {string | null} [instanceStart] 반복 일정 인스턴스 시작 시간 (ISO 8601 형식)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScheduleV1SchedulesScheduleIdDelete: async (scheduleId: string, instanceStart?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('deleteScheduleV1SchedulesScheduleIdDelete', 'scheduleId', scheduleId)
            const localVarPath = `/v1/schedules/{schedule_id}`
                .replace(`{${"schedule_id"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (instanceStart !== undefined) {
                localVarQueryParameter['instance_start'] = (instanceStart as any instanceof Date) ?
                    (instanceStart as any).toISOString() :
                    instanceStart;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 일정의 현재 활성 타이머 조회 (RUNNING 또는 PAUSED, 공유된 일정 포함)  활성 타이머가 없으면 404를 반환합니다.
         * @summary Get Active Timer
         * @param {string} scheduleId 
         * @param {boolean} [includeSchedule] Schedule 정보 포함 여부 (기본값: false)
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveTimerV1SchedulesScheduleIdTimersActiveGet: async (scheduleId: string, includeSchedule?: boolean, timezone?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('getActiveTimerV1SchedulesScheduleIdTimersActiveGet', 'scheduleId', scheduleId)
            const localVarPath = `/v1/schedules/{schedule_id}/timers/active`
                .replace(`{${"schedule_id"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (includeSchedule !== undefined) {
                localVarQueryParameter['include_schedule'] = includeSchedule;
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 일정의 모든 타이머 조회 (공유된 일정 포함)
         * @summary Get Schedule Timers
         * @param {string} scheduleId 
         * @param {boolean} [includeSchedule] Schedule 정보 포함 여부 (기본값: false)
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScheduleTimersV1SchedulesScheduleIdTimersGet: async (scheduleId: string, includeSchedule?: boolean, timezone?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('getScheduleTimersV1SchedulesScheduleIdTimersGet', 'scheduleId', scheduleId)
            const localVarPath = `/v1/schedules/{schedule_id}/timers`
                .replace(`{${"schedule_id"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (includeSchedule !== undefined) {
                localVarQueryParameter['include_schedule'] = includeSchedule;
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ID로 일정 조회 (공유된 일정 포함)  본인 소유 일정 또는 공유 접근 권한이 있는 일정을 조회합니다. 접근 권한이 없으면 403 Forbidden을 반환합니다.
         * @summary Read Schedule
         * @param {string} scheduleId 
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readScheduleV1SchedulesScheduleIdGet: async (scheduleId: string, timezone?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('readScheduleV1SchedulesScheduleIdGet', 'scheduleId', scheduleId)
            const localVarPath = `/v1/schedules/{schedule_id}`
                .replace(`{${"schedule_id"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 날짜 범위 기반 일정 조회 (반복 일정 포함, 태그 필터링 지원)  조회 범위 (scope): - mine: 내 일정만 (기본값) - shared: 공유된 타인의 일정만 - all: 내 일정 + 공유된 일정  날짜 범위: - start_date: 조회 시작 날짜/시간 (필수) - end_date: 조회 종료 날짜/시간 (필수) - 지정된 날짜 범위와 겹치는 모든 일정을 반환 (반복 일정은 가상 인스턴스로 확장)  태그 필터링: - tag_ids: AND 방식 (모든 지정 태그를 포함한 일정만 반환) - group_ids: 해당 그룹의 태그 중 하나라도 있는 일정 반환 - 둘 다 지정 시: 그룹 필터링 후 태그 필터링 적용  FastAPI Best Practices: - async 라우트 사용
         * @summary Read Schedules
         * @param {string} startDate 조회 시작 날짜/시간 (ISO 8601 형식)
         * @param {string} endDate 조회 종료 날짜/시간 (ISO 8601 형식)
         * @param {ResourceScope} [scope] 조회 범위: mine(내 일정만), shared(공유된 일정만), all(모두)
         * @param {Array<string> | null} [tagIds] 태그 ID 리스트 (AND 방식: 모든 지정 태그를 포함한 일정만 반환)
         * @param {Array<string> | null} [groupIds] 태그 그룹 ID 리스트 (해당 그룹의 태그를 가진 일정 반환)
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSchedulesV1SchedulesGet: async (startDate: string, endDate: string, scope?: ResourceScope, tagIds?: Array<string> | null, groupIds?: Array<string> | null, timezone?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists('readSchedulesV1SchedulesGet', 'startDate', startDate)
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists('readSchedulesV1SchedulesGet', 'endDate', endDate)
            const localVarPath = `/v1/schedules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }

            if (tagIds) {
                localVarQueryParameter['tag_ids'] = tagIds;
            }

            if (groupIds) {
                localVarQueryParameter['group_ids'] = groupIds;
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 일정 업데이트 (반복 일정 인스턴스 포함)  일반 일정과 가상 인스턴스 모두 지원: - 일반 일정: schedule_id로 조회하여 업데이트 - 가상 인스턴스: schedule_id를 parent_id로 사용하고 instance_start를 쿼리 파라미터로 전송  ### 요청 예시 ```json {     \"title\": \"업데이트된 제목\" } ```  FastAPI Best Practices: - Service는 session을 받아서 CRUD 직접 사용 - 가상 인스턴스인 경우 instance_start 쿼리 파라미터로 처리
         * @summary Update Schedule
         * @param {string} scheduleId 
         * @param {ScheduleUpdate} scheduleUpdate 
         * @param {string | null} [instanceStart] 반복 일정 인스턴스 시작 시간 (ISO 8601 형식)
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScheduleV1SchedulesScheduleIdPatch: async (scheduleId: string, scheduleUpdate: ScheduleUpdate, instanceStart?: string | null, timezone?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleId' is not null or undefined
            assertParamExists('updateScheduleV1SchedulesScheduleIdPatch', 'scheduleId', scheduleId)
            // verify required parameter 'scheduleUpdate' is not null or undefined
            assertParamExists('updateScheduleV1SchedulesScheduleIdPatch', 'scheduleUpdate', scheduleUpdate)
            const localVarPath = `/v1/schedules/{schedule_id}`
                .replace(`{${"schedule_id"}}`, encodeURIComponent(String(scheduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (instanceStart !== undefined) {
                localVarQueryParameter['instance_start'] = (instanceStart as any instanceof Date) ?
                    (instanceStart as any).toISOString() :
                    instanceStart;
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scheduleUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchedulesApi - functional programming interface
 */
export const SchedulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchedulesApiAxiosParamCreator(configuration)
    return {
        /**
         * 새 일정 생성  FastAPI Best Practices: - async 라우트 사용 - 트랜잭션 자동 관리 (context manager) - Exception Handler가 예외 처리
         * @summary Create Schedule
         * @param {ScheduleCreate} scheduleCreate 
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createScheduleV1SchedulesPost(scheduleCreate: ScheduleCreate, timezone?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createScheduleV1SchedulesPost(scheduleCreate, timezone, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchedulesApi.createScheduleV1SchedulesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 기존 Schedule에서 연관된 Todo 생성  Schedule의 정보를 기반으로 새로운 Todo를 생성합니다: - Todo의 title, description은 Schedule에서 복사 - Todo의 deadline은 Schedule의 start_time으로 설정 - Schedule의 태그가 Todo에도 복사됨 - 생성된 Todo와 Schedule이 source_todo_id로 연결됨  제약사항: - 이미 Todo와 연결된 Schedule에서는 호출 불가 (400 에러) - tag_group_id는 필수 파라미터  :param schedule_id: Schedule ID :param tag_group_id: Todo가 속할 TagGroup ID :return: 생성된 Todo
         * @summary Create Todo From Schedule
         * @param {string} scheduleId 
         * @param {string} tagGroupId Todo가 속할 TagGroup ID (필수)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTodoFromScheduleV1SchedulesScheduleIdTodoPost(scheduleId: string, tagGroupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTodoFromScheduleV1SchedulesScheduleIdTodoPost(scheduleId, tagGroupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchedulesApi.createTodoFromScheduleV1SchedulesScheduleIdTodoPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 일정 삭제 (반복 일정 인스턴스 포함)  일반 일정과 가상 인스턴스 모두 지원: - 일반 일정: schedule_id로 조회하여 삭제 - 가상 인스턴스: schedule_id를 parent_id로 사용하고 instance_start를 쿼리 파라미터로 전송  FastAPI Best Practices: - Service는 session을 받아서 CRUD 직접 사용 - 가상 인스턴스인 경우 instance_start 쿼리 파라미터로 처리
         * @summary Delete Schedule
         * @param {string} scheduleId 
         * @param {string | null} [instanceStart] 반복 일정 인스턴스 시작 시간 (ISO 8601 형식)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScheduleV1SchedulesScheduleIdDelete(scheduleId: string, instanceStart?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScheduleV1SchedulesScheduleIdDelete(scheduleId, instanceStart, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchedulesApi.deleteScheduleV1SchedulesScheduleIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 일정의 현재 활성 타이머 조회 (RUNNING 또는 PAUSED, 공유된 일정 포함)  활성 타이머가 없으면 404를 반환합니다.
         * @summary Get Active Timer
         * @param {string} scheduleId 
         * @param {boolean} [includeSchedule] Schedule 정보 포함 여부 (기본값: false)
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveTimerV1SchedulesScheduleIdTimersActiveGet(scheduleId: string, includeSchedule?: boolean, timezone?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimerRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveTimerV1SchedulesScheduleIdTimersActiveGet(scheduleId, includeSchedule, timezone, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchedulesApi.getActiveTimerV1SchedulesScheduleIdTimersActiveGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 일정의 모든 타이머 조회 (공유된 일정 포함)
         * @summary Get Schedule Timers
         * @param {string} scheduleId 
         * @param {boolean} [includeSchedule] Schedule 정보 포함 여부 (기본값: false)
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScheduleTimersV1SchedulesScheduleIdTimersGet(scheduleId: string, includeSchedule?: boolean, timezone?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TimerRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScheduleTimersV1SchedulesScheduleIdTimersGet(scheduleId, includeSchedule, timezone, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchedulesApi.getScheduleTimersV1SchedulesScheduleIdTimersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ID로 일정 조회 (공유된 일정 포함)  본인 소유 일정 또는 공유 접근 권한이 있는 일정을 조회합니다. 접근 권한이 없으면 403 Forbidden을 반환합니다.
         * @summary Read Schedule
         * @param {string} scheduleId 
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readScheduleV1SchedulesScheduleIdGet(scheduleId: string, timezone?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readScheduleV1SchedulesScheduleIdGet(scheduleId, timezone, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchedulesApi.readScheduleV1SchedulesScheduleIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 날짜 범위 기반 일정 조회 (반복 일정 포함, 태그 필터링 지원)  조회 범위 (scope): - mine: 내 일정만 (기본값) - shared: 공유된 타인의 일정만 - all: 내 일정 + 공유된 일정  날짜 범위: - start_date: 조회 시작 날짜/시간 (필수) - end_date: 조회 종료 날짜/시간 (필수) - 지정된 날짜 범위와 겹치는 모든 일정을 반환 (반복 일정은 가상 인스턴스로 확장)  태그 필터링: - tag_ids: AND 방식 (모든 지정 태그를 포함한 일정만 반환) - group_ids: 해당 그룹의 태그 중 하나라도 있는 일정 반환 - 둘 다 지정 시: 그룹 필터링 후 태그 필터링 적용  FastAPI Best Practices: - async 라우트 사용
         * @summary Read Schedules
         * @param {string} startDate 조회 시작 날짜/시간 (ISO 8601 형식)
         * @param {string} endDate 조회 종료 날짜/시간 (ISO 8601 형식)
         * @param {ResourceScope} [scope] 조회 범위: mine(내 일정만), shared(공유된 일정만), all(모두)
         * @param {Array<string> | null} [tagIds] 태그 ID 리스트 (AND 방식: 모든 지정 태그를 포함한 일정만 반환)
         * @param {Array<string> | null} [groupIds] 태그 그룹 ID 리스트 (해당 그룹의 태그를 가진 일정 반환)
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSchedulesV1SchedulesGet(startDate: string, endDate: string, scope?: ResourceScope, tagIds?: Array<string> | null, groupIds?: Array<string> | null, timezone?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScheduleRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSchedulesV1SchedulesGet(startDate, endDate, scope, tagIds, groupIds, timezone, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchedulesApi.readSchedulesV1SchedulesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 일정 업데이트 (반복 일정 인스턴스 포함)  일반 일정과 가상 인스턴스 모두 지원: - 일반 일정: schedule_id로 조회하여 업데이트 - 가상 인스턴스: schedule_id를 parent_id로 사용하고 instance_start를 쿼리 파라미터로 전송  ### 요청 예시 ```json {     \"title\": \"업데이트된 제목\" } ```  FastAPI Best Practices: - Service는 session을 받아서 CRUD 직접 사용 - 가상 인스턴스인 경우 instance_start 쿼리 파라미터로 처리
         * @summary Update Schedule
         * @param {string} scheduleId 
         * @param {ScheduleUpdate} scheduleUpdate 
         * @param {string | null} [instanceStart] 반복 일정 인스턴스 시작 시간 (ISO 8601 형식)
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateScheduleV1SchedulesScheduleIdPatch(scheduleId: string, scheduleUpdate: ScheduleUpdate, instanceStart?: string | null, timezone?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateScheduleV1SchedulesScheduleIdPatch(scheduleId, scheduleUpdate, instanceStart, timezone, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchedulesApi.updateScheduleV1SchedulesScheduleIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SchedulesApi - factory interface
 */
export const SchedulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchedulesApiFp(configuration)
    return {
        /**
         * 새 일정 생성  FastAPI Best Practices: - async 라우트 사용 - 트랜잭션 자동 관리 (context manager) - Exception Handler가 예외 처리
         * @summary Create Schedule
         * @param {ScheduleCreate} scheduleCreate 
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScheduleV1SchedulesPost(scheduleCreate: ScheduleCreate, timezone?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<ScheduleRead> {
            return localVarFp.createScheduleV1SchedulesPost(scheduleCreate, timezone, options).then((request) => request(axios, basePath));
        },
        /**
         * 기존 Schedule에서 연관된 Todo 생성  Schedule의 정보를 기반으로 새로운 Todo를 생성합니다: - Todo의 title, description은 Schedule에서 복사 - Todo의 deadline은 Schedule의 start_time으로 설정 - Schedule의 태그가 Todo에도 복사됨 - 생성된 Todo와 Schedule이 source_todo_id로 연결됨  제약사항: - 이미 Todo와 연결된 Schedule에서는 호출 불가 (400 에러) - tag_group_id는 필수 파라미터  :param schedule_id: Schedule ID :param tag_group_id: Todo가 속할 TagGroup ID :return: 생성된 Todo
         * @summary Create Todo From Schedule
         * @param {string} scheduleId 
         * @param {string} tagGroupId Todo가 속할 TagGroup ID (필수)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTodoFromScheduleV1SchedulesScheduleIdTodoPost(scheduleId: string, tagGroupId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.createTodoFromScheduleV1SchedulesScheduleIdTodoPost(scheduleId, tagGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 일정 삭제 (반복 일정 인스턴스 포함)  일반 일정과 가상 인스턴스 모두 지원: - 일반 일정: schedule_id로 조회하여 삭제 - 가상 인스턴스: schedule_id를 parent_id로 사용하고 instance_start를 쿼리 파라미터로 전송  FastAPI Best Practices: - Service는 session을 받아서 CRUD 직접 사용 - 가상 인스턴스인 경우 instance_start 쿼리 파라미터로 처리
         * @summary Delete Schedule
         * @param {string} scheduleId 
         * @param {string | null} [instanceStart] 반복 일정 인스턴스 시작 시간 (ISO 8601 형식)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScheduleV1SchedulesScheduleIdDelete(scheduleId: string, instanceStart?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.deleteScheduleV1SchedulesScheduleIdDelete(scheduleId, instanceStart, options).then((request) => request(axios, basePath));
        },
        /**
         * 일정의 현재 활성 타이머 조회 (RUNNING 또는 PAUSED, 공유된 일정 포함)  활성 타이머가 없으면 404를 반환합니다.
         * @summary Get Active Timer
         * @param {string} scheduleId 
         * @param {boolean} [includeSchedule] Schedule 정보 포함 여부 (기본값: false)
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveTimerV1SchedulesScheduleIdTimersActiveGet(scheduleId: string, includeSchedule?: boolean, timezone?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<TimerRead> {
            return localVarFp.getActiveTimerV1SchedulesScheduleIdTimersActiveGet(scheduleId, includeSchedule, timezone, options).then((request) => request(axios, basePath));
        },
        /**
         * 일정의 모든 타이머 조회 (공유된 일정 포함)
         * @summary Get Schedule Timers
         * @param {string} scheduleId 
         * @param {boolean} [includeSchedule] Schedule 정보 포함 여부 (기본값: false)
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScheduleTimersV1SchedulesScheduleIdTimersGet(scheduleId: string, includeSchedule?: boolean, timezone?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<TimerRead>> {
            return localVarFp.getScheduleTimersV1SchedulesScheduleIdTimersGet(scheduleId, includeSchedule, timezone, options).then((request) => request(axios, basePath));
        },
        /**
         * ID로 일정 조회 (공유된 일정 포함)  본인 소유 일정 또는 공유 접근 권한이 있는 일정을 조회합니다. 접근 권한이 없으면 403 Forbidden을 반환합니다.
         * @summary Read Schedule
         * @param {string} scheduleId 
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readScheduleV1SchedulesScheduleIdGet(scheduleId: string, timezone?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<ScheduleRead> {
            return localVarFp.readScheduleV1SchedulesScheduleIdGet(scheduleId, timezone, options).then((request) => request(axios, basePath));
        },
        /**
         * 날짜 범위 기반 일정 조회 (반복 일정 포함, 태그 필터링 지원)  조회 범위 (scope): - mine: 내 일정만 (기본값) - shared: 공유된 타인의 일정만 - all: 내 일정 + 공유된 일정  날짜 범위: - start_date: 조회 시작 날짜/시간 (필수) - end_date: 조회 종료 날짜/시간 (필수) - 지정된 날짜 범위와 겹치는 모든 일정을 반환 (반복 일정은 가상 인스턴스로 확장)  태그 필터링: - tag_ids: AND 방식 (모든 지정 태그를 포함한 일정만 반환) - group_ids: 해당 그룹의 태그 중 하나라도 있는 일정 반환 - 둘 다 지정 시: 그룹 필터링 후 태그 필터링 적용  FastAPI Best Practices: - async 라우트 사용
         * @summary Read Schedules
         * @param {string} startDate 조회 시작 날짜/시간 (ISO 8601 형식)
         * @param {string} endDate 조회 종료 날짜/시간 (ISO 8601 형식)
         * @param {ResourceScope} [scope] 조회 범위: mine(내 일정만), shared(공유된 일정만), all(모두)
         * @param {Array<string> | null} [tagIds] 태그 ID 리스트 (AND 방식: 모든 지정 태그를 포함한 일정만 반환)
         * @param {Array<string> | null} [groupIds] 태그 그룹 ID 리스트 (해당 그룹의 태그를 가진 일정 반환)
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSchedulesV1SchedulesGet(startDate: string, endDate: string, scope?: ResourceScope, tagIds?: Array<string> | null, groupIds?: Array<string> | null, timezone?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<ScheduleRead>> {
            return localVarFp.readSchedulesV1SchedulesGet(startDate, endDate, scope, tagIds, groupIds, timezone, options).then((request) => request(axios, basePath));
        },
        /**
         * 일정 업데이트 (반복 일정 인스턴스 포함)  일반 일정과 가상 인스턴스 모두 지원: - 일반 일정: schedule_id로 조회하여 업데이트 - 가상 인스턴스: schedule_id를 parent_id로 사용하고 instance_start를 쿼리 파라미터로 전송  ### 요청 예시 ```json {     \"title\": \"업데이트된 제목\" } ```  FastAPI Best Practices: - Service는 session을 받아서 CRUD 직접 사용 - 가상 인스턴스인 경우 instance_start 쿼리 파라미터로 처리
         * @summary Update Schedule
         * @param {string} scheduleId 
         * @param {ScheduleUpdate} scheduleUpdate 
         * @param {string | null} [instanceStart] 반복 일정 인스턴스 시작 시간 (ISO 8601 형식)
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScheduleV1SchedulesScheduleIdPatch(scheduleId: string, scheduleUpdate: ScheduleUpdate, instanceStart?: string | null, timezone?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<ScheduleRead> {
            return localVarFp.updateScheduleV1SchedulesScheduleIdPatch(scheduleId, scheduleUpdate, instanceStart, timezone, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchedulesApi - object-oriented interface
 */
export class SchedulesApi extends BaseAPI {
    /**
     * 새 일정 생성  FastAPI Best Practices: - async 라우트 사용 - 트랜잭션 자동 관리 (context manager) - Exception Handler가 예외 처리
     * @summary Create Schedule
     * @param {ScheduleCreate} scheduleCreate 
     * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createScheduleV1SchedulesPost(scheduleCreate: ScheduleCreate, timezone?: string | null, options?: RawAxiosRequestConfig) {
        return SchedulesApiFp(this.configuration).createScheduleV1SchedulesPost(scheduleCreate, timezone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 기존 Schedule에서 연관된 Todo 생성  Schedule의 정보를 기반으로 새로운 Todo를 생성합니다: - Todo의 title, description은 Schedule에서 복사 - Todo의 deadline은 Schedule의 start_time으로 설정 - Schedule의 태그가 Todo에도 복사됨 - 생성된 Todo와 Schedule이 source_todo_id로 연결됨  제약사항: - 이미 Todo와 연결된 Schedule에서는 호출 불가 (400 에러) - tag_group_id는 필수 파라미터  :param schedule_id: Schedule ID :param tag_group_id: Todo가 속할 TagGroup ID :return: 생성된 Todo
     * @summary Create Todo From Schedule
     * @param {string} scheduleId 
     * @param {string} tagGroupId Todo가 속할 TagGroup ID (필수)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createTodoFromScheduleV1SchedulesScheduleIdTodoPost(scheduleId: string, tagGroupId: string, options?: RawAxiosRequestConfig) {
        return SchedulesApiFp(this.configuration).createTodoFromScheduleV1SchedulesScheduleIdTodoPost(scheduleId, tagGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 일정 삭제 (반복 일정 인스턴스 포함)  일반 일정과 가상 인스턴스 모두 지원: - 일반 일정: schedule_id로 조회하여 삭제 - 가상 인스턴스: schedule_id를 parent_id로 사용하고 instance_start를 쿼리 파라미터로 전송  FastAPI Best Practices: - Service는 session을 받아서 CRUD 직접 사용 - 가상 인스턴스인 경우 instance_start 쿼리 파라미터로 처리
     * @summary Delete Schedule
     * @param {string} scheduleId 
     * @param {string | null} [instanceStart] 반복 일정 인스턴스 시작 시간 (ISO 8601 형식)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteScheduleV1SchedulesScheduleIdDelete(scheduleId: string, instanceStart?: string | null, options?: RawAxiosRequestConfig) {
        return SchedulesApiFp(this.configuration).deleteScheduleV1SchedulesScheduleIdDelete(scheduleId, instanceStart, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 일정의 현재 활성 타이머 조회 (RUNNING 또는 PAUSED, 공유된 일정 포함)  활성 타이머가 없으면 404를 반환합니다.
     * @summary Get Active Timer
     * @param {string} scheduleId 
     * @param {boolean} [includeSchedule] Schedule 정보 포함 여부 (기본값: false)
     * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getActiveTimerV1SchedulesScheduleIdTimersActiveGet(scheduleId: string, includeSchedule?: boolean, timezone?: string | null, options?: RawAxiosRequestConfig) {
        return SchedulesApiFp(this.configuration).getActiveTimerV1SchedulesScheduleIdTimersActiveGet(scheduleId, includeSchedule, timezone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 일정의 모든 타이머 조회 (공유된 일정 포함)
     * @summary Get Schedule Timers
     * @param {string} scheduleId 
     * @param {boolean} [includeSchedule] Schedule 정보 포함 여부 (기본값: false)
     * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getScheduleTimersV1SchedulesScheduleIdTimersGet(scheduleId: string, includeSchedule?: boolean, timezone?: string | null, options?: RawAxiosRequestConfig) {
        return SchedulesApiFp(this.configuration).getScheduleTimersV1SchedulesScheduleIdTimersGet(scheduleId, includeSchedule, timezone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ID로 일정 조회 (공유된 일정 포함)  본인 소유 일정 또는 공유 접근 권한이 있는 일정을 조회합니다. 접근 권한이 없으면 403 Forbidden을 반환합니다.
     * @summary Read Schedule
     * @param {string} scheduleId 
     * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public readScheduleV1SchedulesScheduleIdGet(scheduleId: string, timezone?: string | null, options?: RawAxiosRequestConfig) {
        return SchedulesApiFp(this.configuration).readScheduleV1SchedulesScheduleIdGet(scheduleId, timezone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 날짜 범위 기반 일정 조회 (반복 일정 포함, 태그 필터링 지원)  조회 범위 (scope): - mine: 내 일정만 (기본값) - shared: 공유된 타인의 일정만 - all: 내 일정 + 공유된 일정  날짜 범위: - start_date: 조회 시작 날짜/시간 (필수) - end_date: 조회 종료 날짜/시간 (필수) - 지정된 날짜 범위와 겹치는 모든 일정을 반환 (반복 일정은 가상 인스턴스로 확장)  태그 필터링: - tag_ids: AND 방식 (모든 지정 태그를 포함한 일정만 반환) - group_ids: 해당 그룹의 태그 중 하나라도 있는 일정 반환 - 둘 다 지정 시: 그룹 필터링 후 태그 필터링 적용  FastAPI Best Practices: - async 라우트 사용
     * @summary Read Schedules
     * @param {string} startDate 조회 시작 날짜/시간 (ISO 8601 형식)
     * @param {string} endDate 조회 종료 날짜/시간 (ISO 8601 형식)
     * @param {ResourceScope} [scope] 조회 범위: mine(내 일정만), shared(공유된 일정만), all(모두)
     * @param {Array<string> | null} [tagIds] 태그 ID 리스트 (AND 방식: 모든 지정 태그를 포함한 일정만 반환)
     * @param {Array<string> | null} [groupIds] 태그 그룹 ID 리스트 (해당 그룹의 태그를 가진 일정 반환)
     * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public readSchedulesV1SchedulesGet(startDate: string, endDate: string, scope?: ResourceScope, tagIds?: Array<string> | null, groupIds?: Array<string> | null, timezone?: string | null, options?: RawAxiosRequestConfig) {
        return SchedulesApiFp(this.configuration).readSchedulesV1SchedulesGet(startDate, endDate, scope, tagIds, groupIds, timezone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 일정 업데이트 (반복 일정 인스턴스 포함)  일반 일정과 가상 인스턴스 모두 지원: - 일반 일정: schedule_id로 조회하여 업데이트 - 가상 인스턴스: schedule_id를 parent_id로 사용하고 instance_start를 쿼리 파라미터로 전송  ### 요청 예시 ```json {     \"title\": \"업데이트된 제목\" } ```  FastAPI Best Practices: - Service는 session을 받아서 CRUD 직접 사용 - 가상 인스턴스인 경우 instance_start 쿼리 파라미터로 처리
     * @summary Update Schedule
     * @param {string} scheduleId 
     * @param {ScheduleUpdate} scheduleUpdate 
     * @param {string | null} [instanceStart] 반복 일정 인스턴스 시작 시간 (ISO 8601 형식)
     * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateScheduleV1SchedulesScheduleIdPatch(scheduleId: string, scheduleUpdate: ScheduleUpdate, instanceStart?: string | null, timezone?: string | null, options?: RawAxiosRequestConfig) {
        return SchedulesApiFp(this.configuration).updateScheduleV1SchedulesScheduleIdPatch(scheduleId, scheduleUpdate, instanceStart, timezone, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TagsApi - axios parameter creator
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 태그 그룹 생성
         * @summary Create Tag Group
         * @param {TagGroupCreate} tagGroupCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTagGroupV1TagsGroupsPost: async (tagGroupCreate: TagGroupCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagGroupCreate' is not null or undefined
            assertParamExists('createTagGroupV1TagsGroupsPost', 'tagGroupCreate', tagGroupCreate)
            const localVarPath = `/v1/tags/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tagGroupCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 태그 생성
         * @summary Create Tag
         * @param {TagCreate} tagCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTagV1TagsPost: async (tagCreate: TagCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagCreate' is not null or undefined
            assertParamExists('createTagV1TagsPost', 'tagCreate', tagCreate)
            const localVarPath = `/v1/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tagCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 태그 그룹 삭제 (CASCADE로 태그도 삭제)
         * @summary Delete Tag Group
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTagGroupV1TagsGroupsGroupIdDelete: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteTagGroupV1TagsGroupsGroupIdDelete', 'groupId', groupId)
            const localVarPath = `/v1/tags/groups/{group_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 태그 삭제
         * @summary Delete Tag
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTagV1TagsTagIdDelete: async (tagId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('deleteTagV1TagsTagIdDelete', 'tagId', tagId)
            const localVarPath = `/v1/tags/{tag_id}`
                .replace(`{${"tag_id"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 태그 그룹 조회 (태그 포함)
         * @summary Read Tag Group
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTagGroupV1TagsGroupsGroupIdGet: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('readTagGroupV1TagsGroupsGroupIdGet', 'groupId', groupId)
            const localVarPath = `/v1/tags/groups/{group_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 모든 태그 그룹 조회 (태그 포함)
         * @summary Read Tag Groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTagGroupsV1TagsGroupsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/tags/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 태그 조회
         * @summary Read Tag
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTagV1TagsTagIdGet: async (tagId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('readTagV1TagsTagIdGet', 'tagId', tagId)
            const localVarPath = `/v1/tags/{tag_id}`
                .replace(`{${"tag_id"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 모든 태그 조회
         * @summary Read Tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTagsV1TagsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 태그 그룹 업데이트
         * @summary Update Tag Group
         * @param {string} groupId 
         * @param {TagGroupUpdate} tagGroupUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagGroupV1TagsGroupsGroupIdPatch: async (groupId: string, tagGroupUpdate: TagGroupUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateTagGroupV1TagsGroupsGroupIdPatch', 'groupId', groupId)
            // verify required parameter 'tagGroupUpdate' is not null or undefined
            assertParamExists('updateTagGroupV1TagsGroupsGroupIdPatch', 'tagGroupUpdate', tagGroupUpdate)
            const localVarPath = `/v1/tags/groups/{group_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tagGroupUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 태그 업데이트
         * @summary Update Tag
         * @param {string} tagId 
         * @param {TagUpdate} tagUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagV1TagsTagIdPatch: async (tagId: string, tagUpdate: TagUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('updateTagV1TagsTagIdPatch', 'tagId', tagId)
            // verify required parameter 'tagUpdate' is not null or undefined
            assertParamExists('updateTagV1TagsTagIdPatch', 'tagUpdate', tagUpdate)
            const localVarPath = `/v1/tags/{tag_id}`
                .replace(`{${"tag_id"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tagUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 */
export const TagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration)
    return {
        /**
         * 태그 그룹 생성
         * @summary Create Tag Group
         * @param {TagGroupCreate} tagGroupCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTagGroupV1TagsGroupsPost(tagGroupCreate: TagGroupCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagGroupRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTagGroupV1TagsGroupsPost(tagGroupCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.createTagGroupV1TagsGroupsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 태그 생성
         * @summary Create Tag
         * @param {TagCreate} tagCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTagV1TagsPost(tagCreate: TagCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTagV1TagsPost(tagCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.createTagV1TagsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 태그 그룹 삭제 (CASCADE로 태그도 삭제)
         * @summary Delete Tag Group
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTagGroupV1TagsGroupsGroupIdDelete(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTagGroupV1TagsGroupsGroupIdDelete(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.deleteTagGroupV1TagsGroupsGroupIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 태그 삭제
         * @summary Delete Tag
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTagV1TagsTagIdDelete(tagId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTagV1TagsTagIdDelete(tagId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.deleteTagV1TagsTagIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 태그 그룹 조회 (태그 포함)
         * @summary Read Tag Group
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readTagGroupV1TagsGroupsGroupIdGet(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagGroupReadWithTags>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readTagGroupV1TagsGroupsGroupIdGet(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.readTagGroupV1TagsGroupsGroupIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 모든 태그 그룹 조회 (태그 포함)
         * @summary Read Tag Groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readTagGroupsV1TagsGroupsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagGroupReadWithTags>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readTagGroupsV1TagsGroupsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.readTagGroupsV1TagsGroupsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 태그 조회
         * @summary Read Tag
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readTagV1TagsTagIdGet(tagId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readTagV1TagsTagIdGet(tagId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.readTagV1TagsTagIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 모든 태그 조회
         * @summary Read Tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readTagsV1TagsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TagRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readTagsV1TagsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.readTagsV1TagsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 태그 그룹 업데이트
         * @summary Update Tag Group
         * @param {string} groupId 
         * @param {TagGroupUpdate} tagGroupUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTagGroupV1TagsGroupsGroupIdPatch(groupId: string, tagGroupUpdate: TagGroupUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagGroupRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTagGroupV1TagsGroupsGroupIdPatch(groupId, tagGroupUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.updateTagGroupV1TagsGroupsGroupIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 태그 업데이트
         * @summary Update Tag
         * @param {string} tagId 
         * @param {TagUpdate} tagUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTagV1TagsTagIdPatch(tagId: string, tagUpdate: TagUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTagV1TagsTagIdPatch(tagId, tagUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagsApi.updateTagV1TagsTagIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TagsApi - factory interface
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagsApiFp(configuration)
    return {
        /**
         * 태그 그룹 생성
         * @summary Create Tag Group
         * @param {TagGroupCreate} tagGroupCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTagGroupV1TagsGroupsPost(tagGroupCreate: TagGroupCreate, options?: RawAxiosRequestConfig): AxiosPromise<TagGroupRead> {
            return localVarFp.createTagGroupV1TagsGroupsPost(tagGroupCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 태그 생성
         * @summary Create Tag
         * @param {TagCreate} tagCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTagV1TagsPost(tagCreate: TagCreate, options?: RawAxiosRequestConfig): AxiosPromise<TagRead> {
            return localVarFp.createTagV1TagsPost(tagCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 태그 그룹 삭제 (CASCADE로 태그도 삭제)
         * @summary Delete Tag Group
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTagGroupV1TagsGroupsGroupIdDelete(groupId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.deleteTagGroupV1TagsGroupsGroupIdDelete(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 태그 삭제
         * @summary Delete Tag
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTagV1TagsTagIdDelete(tagId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.deleteTagV1TagsTagIdDelete(tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * 태그 그룹 조회 (태그 포함)
         * @summary Read Tag Group
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTagGroupV1TagsGroupsGroupIdGet(groupId: string, options?: RawAxiosRequestConfig): AxiosPromise<TagGroupReadWithTags> {
            return localVarFp.readTagGroupV1TagsGroupsGroupIdGet(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 모든 태그 그룹 조회 (태그 포함)
         * @summary Read Tag Groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTagGroupsV1TagsGroupsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<TagGroupReadWithTags>> {
            return localVarFp.readTagGroupsV1TagsGroupsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 태그 조회
         * @summary Read Tag
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTagV1TagsTagIdGet(tagId: string, options?: RawAxiosRequestConfig): AxiosPromise<TagRead> {
            return localVarFp.readTagV1TagsTagIdGet(tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * 모든 태그 조회
         * @summary Read Tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTagsV1TagsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<TagRead>> {
            return localVarFp.readTagsV1TagsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 태그 그룹 업데이트
         * @summary Update Tag Group
         * @param {string} groupId 
         * @param {TagGroupUpdate} tagGroupUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagGroupV1TagsGroupsGroupIdPatch(groupId: string, tagGroupUpdate: TagGroupUpdate, options?: RawAxiosRequestConfig): AxiosPromise<TagGroupRead> {
            return localVarFp.updateTagGroupV1TagsGroupsGroupIdPatch(groupId, tagGroupUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 태그 업데이트
         * @summary Update Tag
         * @param {string} tagId 
         * @param {TagUpdate} tagUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagV1TagsTagIdPatch(tagId: string, tagUpdate: TagUpdate, options?: RawAxiosRequestConfig): AxiosPromise<TagRead> {
            return localVarFp.updateTagV1TagsTagIdPatch(tagId, tagUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagsApi - object-oriented interface
 */
export class TagsApi extends BaseAPI {
    /**
     * 태그 그룹 생성
     * @summary Create Tag Group
     * @param {TagGroupCreate} tagGroupCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createTagGroupV1TagsGroupsPost(tagGroupCreate: TagGroupCreate, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).createTagGroupV1TagsGroupsPost(tagGroupCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 태그 생성
     * @summary Create Tag
     * @param {TagCreate} tagCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createTagV1TagsPost(tagCreate: TagCreate, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).createTagV1TagsPost(tagCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 태그 그룹 삭제 (CASCADE로 태그도 삭제)
     * @summary Delete Tag Group
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteTagGroupV1TagsGroupsGroupIdDelete(groupId: string, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).deleteTagGroupV1TagsGroupsGroupIdDelete(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 태그 삭제
     * @summary Delete Tag
     * @param {string} tagId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteTagV1TagsTagIdDelete(tagId: string, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).deleteTagV1TagsTagIdDelete(tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 태그 그룹 조회 (태그 포함)
     * @summary Read Tag Group
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public readTagGroupV1TagsGroupsGroupIdGet(groupId: string, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).readTagGroupV1TagsGroupsGroupIdGet(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 모든 태그 그룹 조회 (태그 포함)
     * @summary Read Tag Groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public readTagGroupsV1TagsGroupsGet(options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).readTagGroupsV1TagsGroupsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 태그 조회
     * @summary Read Tag
     * @param {string} tagId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public readTagV1TagsTagIdGet(tagId: string, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).readTagV1TagsTagIdGet(tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 모든 태그 조회
     * @summary Read Tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public readTagsV1TagsGet(options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).readTagsV1TagsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 태그 그룹 업데이트
     * @summary Update Tag Group
     * @param {string} groupId 
     * @param {TagGroupUpdate} tagGroupUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateTagGroupV1TagsGroupsGroupIdPatch(groupId: string, tagGroupUpdate: TagGroupUpdate, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).updateTagGroupV1TagsGroupsGroupIdPatch(groupId, tagGroupUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 태그 업데이트
     * @summary Update Tag
     * @param {string} tagId 
     * @param {TagUpdate} tagUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateTagV1TagsTagIdPatch(tagId: string, tagUpdate: TagUpdate, options?: RawAxiosRequestConfig) {
        return TagsApiFp(this.configuration).updateTagV1TagsTagIdPatch(tagId, tagUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TimersApi - axios parameter creator
 */
export const TimersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 타이머 삭제
         * @summary Delete Timer
         * @param {string} timerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTimerV1TimersTimerIdDelete: async (timerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timerId' is not null or undefined
            assertParamExists('deleteTimerV1TimersTimerIdDelete', 'timerId', timerId)
            const localVarPath = `/v1/timers/{timer_id}`
                .replace(`{${"timer_id"}}`, encodeURIComponent(String(timerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 타이머 조회 (공유된 타이머 포함)  본인 소유 타이머 또는 공유 접근 권한이 있는 타이머를 조회합니다. 접근 권한이 없으면 403 Forbidden을 반환합니다.
         * @summary Get Timer
         * @param {string} timerId 
         * @param {boolean} [includeSchedule] Schedule 정보 포함 여부 (기본값: false)
         * @param {boolean} [includeTodo] Todo 정보 포함 여부 (기본값: false)
         * @param {TagIncludeMode} [tagIncludeMode] 태그 포함 모드: none(포함 안 함), timer_only(타이머 태그만), inherit_from_schedule(스케줄/Todo 태그 상속)
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimerV1TimersTimerIdGet: async (timerId: string, includeSchedule?: boolean, includeTodo?: boolean, tagIncludeMode?: TagIncludeMode, timezone?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timerId' is not null or undefined
            assertParamExists('getTimerV1TimersTimerIdGet', 'timerId', timerId)
            const localVarPath = `/v1/timers/{timer_id}`
                .replace(`{${"timer_id"}}`, encodeURIComponent(String(timerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (includeSchedule !== undefined) {
                localVarQueryParameter['include_schedule'] = includeSchedule;
            }

            if (includeTodo !== undefined) {
                localVarQueryParameter['include_todo'] = includeTodo;
            }

            if (tagIncludeMode !== undefined) {
                localVarQueryParameter['tag_include_mode'] = tagIncludeMode;
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 사용자의 현재 활성 타이머 조회 (RUNNING 또는 PAUSED)  활성 타이머가 없으면 404 반환 여러 개가 있으면 가장 최근 것 반환
         * @summary Get User Active Timer
         * @param {boolean} [includeSchedule] Schedule 정보 포함 여부 (기본값: false)
         * @param {boolean} [includeTodo] Todo 정보 포함 여부 (기본값: false)
         * @param {TagIncludeMode} [tagIncludeMode] 태그 포함 모드: none(포함 안 함), timer_only(타이머 태그만), inherit_from_schedule(스케줄/Todo 태그 상속)
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserActiveTimerV1TimersActiveGet: async (includeSchedule?: boolean, includeTodo?: boolean, tagIncludeMode?: TagIncludeMode, timezone?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/timers/active`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (includeSchedule !== undefined) {
                localVarQueryParameter['include_schedule'] = includeSchedule;
            }

            if (includeTodo !== undefined) {
                localVarQueryParameter['include_todo'] = includeTodo;
            }

            if (tagIncludeMode !== undefined) {
                localVarQueryParameter['tag_include_mode'] = tagIncludeMode;
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 타이머 목록 조회  조회 범위 (scope): - mine: 내 타이머만 (기본값) - shared: 공유된 타인의 타이머만 - all: 내 타이머 + 공유된 타이머  필터링 옵션: - status: 상태 필터 (RUNNING, PAUSED, COMPLETED, CANCELLED) - 복수 선택 가능 - type: 타입 필터   - independent: 독립 타이머 (schedule_id=null AND todo_id=null)   - schedule: Schedule 연결 타이머 (schedule_id != null)   - todo: Todo 연결 타이머 (todo_id != null) - start_date, end_date: 날짜 범위 필터 (started_at 기준)
         * @summary List Timers
         * @param {ResourceScope} [scope] 조회 범위: mine(내 타이머만), shared(공유된 타이머만), all(모두)
         * @param {Array<string> | null} [status] 상태 필터 (RUNNING, PAUSED, COMPLETED, CANCELLED) - 복수 선택 가능
         * @param {string | null} [type] 타입 필터: independent(독립 타이머), schedule(Schedule 연결), todo(Todo 연결)
         * @param {string | null} [startDate] 시작 날짜 필터 (started_at 기준, ISO 8601 형식)
         * @param {string | null} [endDate] 종료 날짜 필터 (started_at 기준, ISO 8601 형식)
         * @param {boolean} [includeSchedule] Schedule 정보 포함 여부 (기본값: false)
         * @param {boolean} [includeTodo] Todo 정보 포함 여부 (기본값: false)
         * @param {TagIncludeMode} [tagIncludeMode] 태그 포함 모드: none(포함 안 함), timer_only(타이머 태그만), inherit_from_schedule(스케줄/Todo 태그 상속)
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTimersV1TimersGet: async (scope?: ResourceScope, status?: Array<string> | null, type?: string | null, startDate?: string | null, endDate?: string | null, includeSchedule?: boolean, includeTodo?: boolean, tagIncludeMode?: TagIncludeMode, timezone?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/timers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }

            if (status) {
                localVarQueryParameter['status'] = status;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (includeSchedule !== undefined) {
                localVarQueryParameter['include_schedule'] = includeSchedule;
            }

            if (includeTodo !== undefined) {
                localVarQueryParameter['include_todo'] = includeTodo;
            }

            if (tagIncludeMode !== undefined) {
                localVarQueryParameter['tag_include_mode'] = tagIncludeMode;
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 타이머 메타데이터 업데이트 (title, description, tags)
         * @summary Update Timer
         * @param {string} timerId 
         * @param {TimerUpdate} timerUpdate 
         * @param {boolean} [includeSchedule] Schedule 정보 포함 여부 (기본값: false)
         * @param {boolean} [includeTodo] Todo 정보 포함 여부 (기본값: false)
         * @param {TagIncludeMode} [tagIncludeMode] 태그 포함 모드: none(포함 안 함), timer_only(타이머 태그만), inherit_from_schedule(스케줄/Todo 태그 상속)
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTimerV1TimersTimerIdPatch: async (timerId: string, timerUpdate: TimerUpdate, includeSchedule?: boolean, includeTodo?: boolean, tagIncludeMode?: TagIncludeMode, timezone?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timerId' is not null or undefined
            assertParamExists('updateTimerV1TimersTimerIdPatch', 'timerId', timerId)
            // verify required parameter 'timerUpdate' is not null or undefined
            assertParamExists('updateTimerV1TimersTimerIdPatch', 'timerUpdate', timerUpdate)
            const localVarPath = `/v1/timers/{timer_id}`
                .replace(`{${"timer_id"}}`, encodeURIComponent(String(timerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (includeSchedule !== undefined) {
                localVarQueryParameter['include_schedule'] = includeSchedule;
            }

            if (includeTodo !== undefined) {
                localVarQueryParameter['include_todo'] = includeTodo;
            }

            if (tagIncludeMode !== undefined) {
                localVarQueryParameter['tag_include_mode'] = tagIncludeMode;
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(timerUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimersApi - functional programming interface
 */
export const TimersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TimersApiAxiosParamCreator(configuration)
    return {
        /**
         * 타이머 삭제
         * @summary Delete Timer
         * @param {string} timerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTimerV1TimersTimerIdDelete(timerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTimerV1TimersTimerIdDelete(timerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TimersApi.deleteTimerV1TimersTimerIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 타이머 조회 (공유된 타이머 포함)  본인 소유 타이머 또는 공유 접근 권한이 있는 타이머를 조회합니다. 접근 권한이 없으면 403 Forbidden을 반환합니다.
         * @summary Get Timer
         * @param {string} timerId 
         * @param {boolean} [includeSchedule] Schedule 정보 포함 여부 (기본값: false)
         * @param {boolean} [includeTodo] Todo 정보 포함 여부 (기본값: false)
         * @param {TagIncludeMode} [tagIncludeMode] 태그 포함 모드: none(포함 안 함), timer_only(타이머 태그만), inherit_from_schedule(스케줄/Todo 태그 상속)
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimerV1TimersTimerIdGet(timerId: string, includeSchedule?: boolean, includeTodo?: boolean, tagIncludeMode?: TagIncludeMode, timezone?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimerRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTimerV1TimersTimerIdGet(timerId, includeSchedule, includeTodo, tagIncludeMode, timezone, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TimersApi.getTimerV1TimersTimerIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 사용자의 현재 활성 타이머 조회 (RUNNING 또는 PAUSED)  활성 타이머가 없으면 404 반환 여러 개가 있으면 가장 최근 것 반환
         * @summary Get User Active Timer
         * @param {boolean} [includeSchedule] Schedule 정보 포함 여부 (기본값: false)
         * @param {boolean} [includeTodo] Todo 정보 포함 여부 (기본값: false)
         * @param {TagIncludeMode} [tagIncludeMode] 태그 포함 모드: none(포함 안 함), timer_only(타이머 태그만), inherit_from_schedule(스케줄/Todo 태그 상속)
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserActiveTimerV1TimersActiveGet(includeSchedule?: boolean, includeTodo?: boolean, tagIncludeMode?: TagIncludeMode, timezone?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimerRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserActiveTimerV1TimersActiveGet(includeSchedule, includeTodo, tagIncludeMode, timezone, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TimersApi.getUserActiveTimerV1TimersActiveGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 타이머 목록 조회  조회 범위 (scope): - mine: 내 타이머만 (기본값) - shared: 공유된 타인의 타이머만 - all: 내 타이머 + 공유된 타이머  필터링 옵션: - status: 상태 필터 (RUNNING, PAUSED, COMPLETED, CANCELLED) - 복수 선택 가능 - type: 타입 필터   - independent: 독립 타이머 (schedule_id=null AND todo_id=null)   - schedule: Schedule 연결 타이머 (schedule_id != null)   - todo: Todo 연결 타이머 (todo_id != null) - start_date, end_date: 날짜 범위 필터 (started_at 기준)
         * @summary List Timers
         * @param {ResourceScope} [scope] 조회 범위: mine(내 타이머만), shared(공유된 타이머만), all(모두)
         * @param {Array<string> | null} [status] 상태 필터 (RUNNING, PAUSED, COMPLETED, CANCELLED) - 복수 선택 가능
         * @param {string | null} [type] 타입 필터: independent(독립 타이머), schedule(Schedule 연결), todo(Todo 연결)
         * @param {string | null} [startDate] 시작 날짜 필터 (started_at 기준, ISO 8601 형식)
         * @param {string | null} [endDate] 종료 날짜 필터 (started_at 기준, ISO 8601 형식)
         * @param {boolean} [includeSchedule] Schedule 정보 포함 여부 (기본값: false)
         * @param {boolean} [includeTodo] Todo 정보 포함 여부 (기본값: false)
         * @param {TagIncludeMode} [tagIncludeMode] 태그 포함 모드: none(포함 안 함), timer_only(타이머 태그만), inherit_from_schedule(스케줄/Todo 태그 상속)
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTimersV1TimersGet(scope?: ResourceScope, status?: Array<string> | null, type?: string | null, startDate?: string | null, endDate?: string | null, includeSchedule?: boolean, includeTodo?: boolean, tagIncludeMode?: TagIncludeMode, timezone?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TimerRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTimersV1TimersGet(scope, status, type, startDate, endDate, includeSchedule, includeTodo, tagIncludeMode, timezone, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TimersApi.listTimersV1TimersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 타이머 메타데이터 업데이트 (title, description, tags)
         * @summary Update Timer
         * @param {string} timerId 
         * @param {TimerUpdate} timerUpdate 
         * @param {boolean} [includeSchedule] Schedule 정보 포함 여부 (기본값: false)
         * @param {boolean} [includeTodo] Todo 정보 포함 여부 (기본값: false)
         * @param {TagIncludeMode} [tagIncludeMode] 태그 포함 모드: none(포함 안 함), timer_only(타이머 태그만), inherit_from_schedule(스케줄/Todo 태그 상속)
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTimerV1TimersTimerIdPatch(timerId: string, timerUpdate: TimerUpdate, includeSchedule?: boolean, includeTodo?: boolean, tagIncludeMode?: TagIncludeMode, timezone?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimerRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTimerV1TimersTimerIdPatch(timerId, timerUpdate, includeSchedule, includeTodo, tagIncludeMode, timezone, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TimersApi.updateTimerV1TimersTimerIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TimersApi - factory interface
 */
export const TimersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TimersApiFp(configuration)
    return {
        /**
         * 타이머 삭제
         * @summary Delete Timer
         * @param {string} timerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTimerV1TimersTimerIdDelete(timerId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.deleteTimerV1TimersTimerIdDelete(timerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 타이머 조회 (공유된 타이머 포함)  본인 소유 타이머 또는 공유 접근 권한이 있는 타이머를 조회합니다. 접근 권한이 없으면 403 Forbidden을 반환합니다.
         * @summary Get Timer
         * @param {string} timerId 
         * @param {boolean} [includeSchedule] Schedule 정보 포함 여부 (기본값: false)
         * @param {boolean} [includeTodo] Todo 정보 포함 여부 (기본값: false)
         * @param {TagIncludeMode} [tagIncludeMode] 태그 포함 모드: none(포함 안 함), timer_only(타이머 태그만), inherit_from_schedule(스케줄/Todo 태그 상속)
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimerV1TimersTimerIdGet(timerId: string, includeSchedule?: boolean, includeTodo?: boolean, tagIncludeMode?: TagIncludeMode, timezone?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<TimerRead> {
            return localVarFp.getTimerV1TimersTimerIdGet(timerId, includeSchedule, includeTodo, tagIncludeMode, timezone, options).then((request) => request(axios, basePath));
        },
        /**
         * 사용자의 현재 활성 타이머 조회 (RUNNING 또는 PAUSED)  활성 타이머가 없으면 404 반환 여러 개가 있으면 가장 최근 것 반환
         * @summary Get User Active Timer
         * @param {boolean} [includeSchedule] Schedule 정보 포함 여부 (기본값: false)
         * @param {boolean} [includeTodo] Todo 정보 포함 여부 (기본값: false)
         * @param {TagIncludeMode} [tagIncludeMode] 태그 포함 모드: none(포함 안 함), timer_only(타이머 태그만), inherit_from_schedule(스케줄/Todo 태그 상속)
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserActiveTimerV1TimersActiveGet(includeSchedule?: boolean, includeTodo?: boolean, tagIncludeMode?: TagIncludeMode, timezone?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<TimerRead> {
            return localVarFp.getUserActiveTimerV1TimersActiveGet(includeSchedule, includeTodo, tagIncludeMode, timezone, options).then((request) => request(axios, basePath));
        },
        /**
         * 타이머 목록 조회  조회 범위 (scope): - mine: 내 타이머만 (기본값) - shared: 공유된 타인의 타이머만 - all: 내 타이머 + 공유된 타이머  필터링 옵션: - status: 상태 필터 (RUNNING, PAUSED, COMPLETED, CANCELLED) - 복수 선택 가능 - type: 타입 필터   - independent: 독립 타이머 (schedule_id=null AND todo_id=null)   - schedule: Schedule 연결 타이머 (schedule_id != null)   - todo: Todo 연결 타이머 (todo_id != null) - start_date, end_date: 날짜 범위 필터 (started_at 기준)
         * @summary List Timers
         * @param {ResourceScope} [scope] 조회 범위: mine(내 타이머만), shared(공유된 타이머만), all(모두)
         * @param {Array<string> | null} [status] 상태 필터 (RUNNING, PAUSED, COMPLETED, CANCELLED) - 복수 선택 가능
         * @param {string | null} [type] 타입 필터: independent(독립 타이머), schedule(Schedule 연결), todo(Todo 연결)
         * @param {string | null} [startDate] 시작 날짜 필터 (started_at 기준, ISO 8601 형식)
         * @param {string | null} [endDate] 종료 날짜 필터 (started_at 기준, ISO 8601 형식)
         * @param {boolean} [includeSchedule] Schedule 정보 포함 여부 (기본값: false)
         * @param {boolean} [includeTodo] Todo 정보 포함 여부 (기본값: false)
         * @param {TagIncludeMode} [tagIncludeMode] 태그 포함 모드: none(포함 안 함), timer_only(타이머 태그만), inherit_from_schedule(스케줄/Todo 태그 상속)
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTimersV1TimersGet(scope?: ResourceScope, status?: Array<string> | null, type?: string | null, startDate?: string | null, endDate?: string | null, includeSchedule?: boolean, includeTodo?: boolean, tagIncludeMode?: TagIncludeMode, timezone?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<TimerRead>> {
            return localVarFp.listTimersV1TimersGet(scope, status, type, startDate, endDate, includeSchedule, includeTodo, tagIncludeMode, timezone, options).then((request) => request(axios, basePath));
        },
        /**
         * 타이머 메타데이터 업데이트 (title, description, tags)
         * @summary Update Timer
         * @param {string} timerId 
         * @param {TimerUpdate} timerUpdate 
         * @param {boolean} [includeSchedule] Schedule 정보 포함 여부 (기본값: false)
         * @param {boolean} [includeTodo] Todo 정보 포함 여부 (기본값: false)
         * @param {TagIncludeMode} [tagIncludeMode] 태그 포함 모드: none(포함 안 함), timer_only(타이머 태그만), inherit_from_schedule(스케줄/Todo 태그 상속)
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTimerV1TimersTimerIdPatch(timerId: string, timerUpdate: TimerUpdate, includeSchedule?: boolean, includeTodo?: boolean, tagIncludeMode?: TagIncludeMode, timezone?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<TimerRead> {
            return localVarFp.updateTimerV1TimersTimerIdPatch(timerId, timerUpdate, includeSchedule, includeTodo, tagIncludeMode, timezone, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TimersApi - object-oriented interface
 */
export class TimersApi extends BaseAPI {
    /**
     * 타이머 삭제
     * @summary Delete Timer
     * @param {string} timerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteTimerV1TimersTimerIdDelete(timerId: string, options?: RawAxiosRequestConfig) {
        return TimersApiFp(this.configuration).deleteTimerV1TimersTimerIdDelete(timerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 타이머 조회 (공유된 타이머 포함)  본인 소유 타이머 또는 공유 접근 권한이 있는 타이머를 조회합니다. 접근 권한이 없으면 403 Forbidden을 반환합니다.
     * @summary Get Timer
     * @param {string} timerId 
     * @param {boolean} [includeSchedule] Schedule 정보 포함 여부 (기본값: false)
     * @param {boolean} [includeTodo] Todo 정보 포함 여부 (기본값: false)
     * @param {TagIncludeMode} [tagIncludeMode] 태그 포함 모드: none(포함 안 함), timer_only(타이머 태그만), inherit_from_schedule(스케줄/Todo 태그 상속)
     * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTimerV1TimersTimerIdGet(timerId: string, includeSchedule?: boolean, includeTodo?: boolean, tagIncludeMode?: TagIncludeMode, timezone?: string | null, options?: RawAxiosRequestConfig) {
        return TimersApiFp(this.configuration).getTimerV1TimersTimerIdGet(timerId, includeSchedule, includeTodo, tagIncludeMode, timezone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 사용자의 현재 활성 타이머 조회 (RUNNING 또는 PAUSED)  활성 타이머가 없으면 404 반환 여러 개가 있으면 가장 최근 것 반환
     * @summary Get User Active Timer
     * @param {boolean} [includeSchedule] Schedule 정보 포함 여부 (기본값: false)
     * @param {boolean} [includeTodo] Todo 정보 포함 여부 (기본값: false)
     * @param {TagIncludeMode} [tagIncludeMode] 태그 포함 모드: none(포함 안 함), timer_only(타이머 태그만), inherit_from_schedule(스케줄/Todo 태그 상속)
     * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUserActiveTimerV1TimersActiveGet(includeSchedule?: boolean, includeTodo?: boolean, tagIncludeMode?: TagIncludeMode, timezone?: string | null, options?: RawAxiosRequestConfig) {
        return TimersApiFp(this.configuration).getUserActiveTimerV1TimersActiveGet(includeSchedule, includeTodo, tagIncludeMode, timezone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 타이머 목록 조회  조회 범위 (scope): - mine: 내 타이머만 (기본값) - shared: 공유된 타인의 타이머만 - all: 내 타이머 + 공유된 타이머  필터링 옵션: - status: 상태 필터 (RUNNING, PAUSED, COMPLETED, CANCELLED) - 복수 선택 가능 - type: 타입 필터   - independent: 독립 타이머 (schedule_id=null AND todo_id=null)   - schedule: Schedule 연결 타이머 (schedule_id != null)   - todo: Todo 연결 타이머 (todo_id != null) - start_date, end_date: 날짜 범위 필터 (started_at 기준)
     * @summary List Timers
     * @param {ResourceScope} [scope] 조회 범위: mine(내 타이머만), shared(공유된 타이머만), all(모두)
     * @param {Array<string> | null} [status] 상태 필터 (RUNNING, PAUSED, COMPLETED, CANCELLED) - 복수 선택 가능
     * @param {string | null} [type] 타입 필터: independent(독립 타이머), schedule(Schedule 연결), todo(Todo 연결)
     * @param {string | null} [startDate] 시작 날짜 필터 (started_at 기준, ISO 8601 형식)
     * @param {string | null} [endDate] 종료 날짜 필터 (started_at 기준, ISO 8601 형식)
     * @param {boolean} [includeSchedule] Schedule 정보 포함 여부 (기본값: false)
     * @param {boolean} [includeTodo] Todo 정보 포함 여부 (기본값: false)
     * @param {TagIncludeMode} [tagIncludeMode] 태그 포함 모드: none(포함 안 함), timer_only(타이머 태그만), inherit_from_schedule(스케줄/Todo 태그 상속)
     * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listTimersV1TimersGet(scope?: ResourceScope, status?: Array<string> | null, type?: string | null, startDate?: string | null, endDate?: string | null, includeSchedule?: boolean, includeTodo?: boolean, tagIncludeMode?: TagIncludeMode, timezone?: string | null, options?: RawAxiosRequestConfig) {
        return TimersApiFp(this.configuration).listTimersV1TimersGet(scope, status, type, startDate, endDate, includeSchedule, includeTodo, tagIncludeMode, timezone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 타이머 메타데이터 업데이트 (title, description, tags)
     * @summary Update Timer
     * @param {string} timerId 
     * @param {TimerUpdate} timerUpdate 
     * @param {boolean} [includeSchedule] Schedule 정보 포함 여부 (기본값: false)
     * @param {boolean} [includeTodo] Todo 정보 포함 여부 (기본값: false)
     * @param {TagIncludeMode} [tagIncludeMode] 태그 포함 모드: none(포함 안 함), timer_only(타이머 태그만), inherit_from_schedule(스케줄/Todo 태그 상속)
     * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateTimerV1TimersTimerIdPatch(timerId: string, timerUpdate: TimerUpdate, includeSchedule?: boolean, includeTodo?: boolean, tagIncludeMode?: TagIncludeMode, timezone?: string | null, options?: RawAxiosRequestConfig) {
        return TimersApiFp(this.configuration).updateTimerV1TimersTimerIdPatch(timerId, timerUpdate, includeSchedule, includeTodo, tagIncludeMode, timezone, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TodosApi - axios parameter creator
 */
export const TodosApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 새 Todo 생성  Todo는 독립적인 엔티티입니다. deadline이 있으면 별도의 Schedule이 자동으로 생성됩니다.
         * @summary Create Todo
         * @param {TodoCreate} todoCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTodoV1TodosPost: async (todoCreate: TodoCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'todoCreate' is not null or undefined
            assertParamExists('createTodoV1TodosPost', 'todoCreate', todoCreate)
            const localVarPath = `/v1/todos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(todoCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Todo 삭제
         * @summary Delete Todo
         * @param {string} todoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTodoV1TodosTodoIdDelete: async (todoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'todoId' is not null or undefined
            assertParamExists('deleteTodoV1TodosTodoIdDelete', 'todoId', todoId)
            const localVarPath = `/v1/todos/{todo_id}`
                .replace(`{${"todo_id"}}`, encodeURIComponent(String(todoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 프리셋 상세 조회  프리셋의 TagGroup, Tag, Todo 구조를 미리 확인할 수 있습니다.
         * @summary Get Preset
         * @param {string} presetName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresetV1TodosPresetsPresetNameGet: async (presetName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'presetName' is not null or undefined
            assertParamExists('getPresetV1TodosPresetsPresetNameGet', 'presetName', presetName)
            const localVarPath = `/v1/todos/presets/{preset_name}`
                .replace(`{${"preset_name"}}`, encodeURIComponent(String(presetName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Todo의 현재 활성 타이머 조회 (RUNNING 또는 PAUSED, 공유된 Todo 포함)  활성 타이머가 없으면 404를 반환합니다. Schedule의 /schedules/{schedule_id}/timers/active 엔드포인트와 동일한 패턴입니다.
         * @summary Get Todo Active Timer
         * @param {string} todoId 
         * @param {boolean} [includeTodo] Todo 정보 포함 여부 (기본값: false)
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTodoActiveTimerV1TodosTodoIdTimersActiveGet: async (todoId: string, includeTodo?: boolean, timezone?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'todoId' is not null or undefined
            assertParamExists('getTodoActiveTimerV1TodosTodoIdTimersActiveGet', 'todoId', todoId)
            const localVarPath = `/v1/todos/{todo_id}/timers/active`
                .replace(`{${"todo_id"}}`, encodeURIComponent(String(todoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (includeTodo !== undefined) {
                localVarQueryParameter['include_todo'] = includeTodo;
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Todo 통계 조회  그룹별 태그 통계를 반환합니다. group_id가 지정되면 해당 그룹의 태그만 집계합니다.
         * @summary Get Todo Stats
         * @param {string | null} [groupId] 필터링할 태그 그룹 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTodoStatsV1TodosStatsGet: async (groupId?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/todos/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (groupId !== undefined) {
                localVarQueryParameter['group_id'] = groupId;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Todo의 모든 타이머 조회 (공유된 Todo 포함)  Schedule의 /schedules/{schedule_id}/timers 엔드포인트와 동일한 패턴입니다.
         * @summary Get Todo Timers
         * @param {string} todoId 
         * @param {boolean} [includeTodo] Todo 정보 포함 여부 (기본값: false)
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTodoTimersV1TodosTodoIdTimersGet: async (todoId: string, includeTodo?: boolean, timezone?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'todoId' is not null or undefined
            assertParamExists('getTodoTimersV1TodosTodoIdTimersGet', 'todoId', todoId)
            const localVarPath = `/v1/todos/{todo_id}/timers`
                .replace(`{${"todo_id"}}`, encodeURIComponent(String(todoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (includeTodo !== undefined) {
                localVarQueryParameter['include_todo'] = includeTodo;
            }

            if (timezone !== undefined) {
                localVarQueryParameter['timezone'] = timezone;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 프리셋으로 Todo 초기화  지정한 프리셋을 사용하여 TagGroup, Tag, Todo를 일괄 생성합니다.  - TagGroup 1개 생성 - 프리셋에 정의된 Tag들 생성 - 프리셋에 정의된 Todo들 생성 (계층 구조 지원)
         * @summary Initialize From Preset
         * @param {string} presetName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initializeFromPresetV1TodosInitializePresetNamePost: async (presetName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'presetName' is not null or undefined
            assertParamExists('initializeFromPresetV1TodosInitializePresetNamePost', 'presetName', presetName)
            const localVarPath = `/v1/todos/initialize/{preset_name}`
                .replace(`{${"preset_name"}}`, encodeURIComponent(String(presetName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 사용 가능한 프리셋 목록 조회  프리셋은 TagGroup, Tag, Todo를 일괄 생성하기 위한 템플릿입니다.
         * @summary List Presets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPresetsV1TodosPresetsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/todos/presets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ID로 Todo 조회 (공유된 Todo 포함)  본인 소유 Todo 또는 공유 접근 권한이 있는 Todo를 조회합니다. 접근 권한이 없으면 403 Forbidden을 반환합니다.
         * @summary Read Todo
         * @param {string} todoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTodoV1TodosTodoIdGet: async (todoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'todoId' is not null or undefined
            assertParamExists('readTodoV1TodosTodoIdGet', 'todoId', todoId)
            const localVarPath = `/v1/todos/{todo_id}`
                .replace(`{${"todo_id"}}`, encodeURIComponent(String(todoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Todo 목록 조회 (태그/그룹 필터링 지원)  조회 범위 (scope): - mine: 내 Todo만 (기본값) - shared: 공유된 타인의 Todo만 - all: 내 Todo + 공유된 Todo  그룹 필터링: - group_ids: 해당 그룹에 속한 Todo 반환   - tag_group_id로 직접 연결된 Todo   - OR 해당 그룹의 태그를 가진 Todo  태그 필터링: - tag_ids: AND 방식 (모든 지정 태그를 포함한 Todo만 반환) - 태그 필터 시 조상 노드도 포함 (orphan 방지)  응답의 include_reason 필드: - MATCH: 필터 조건에 직접 매칭된 Todo - ANCESTOR: 매칭된 Todo의 조상이라 포함된 Todo  둘 다 지정 시: 그룹 필터링 후 태그 필터링 적용
         * @summary Read Todos
         * @param {ResourceScope} [scope] 조회 범위: mine(내 Todo만), shared(공유된 Todo만), all(모두)
         * @param {Array<string> | null} [tagIds] 태그 ID 리스트 (AND 방식: 모든 지정 태그를 포함한 Todo만 반환)
         * @param {Array<string> | null} [groupIds] 태그 그룹 ID 리스트 (해당 그룹에 속한 Todo 반환 - 직접 연결 또는 태그 기반)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTodosV1TodosGet: async (scope?: ResourceScope, tagIds?: Array<string> | null, groupIds?: Array<string> | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/todos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }

            if (tagIds) {
                localVarQueryParameter['tag_ids'] = tagIds;
            }

            if (groupIds) {
                localVarQueryParameter['group_ids'] = groupIds;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Todo 업데이트  title, description, tag_ids, deadline, parent_id, status를 업데이트할 수 있습니다.  deadline 변경 시: - deadline 추가: 새 Schedule 생성 - deadline 변경: 기존 Schedule 업데이트 - deadline 제거: 기존 Schedule 삭제
         * @summary Update Todo
         * @param {string} todoId 
         * @param {TodoUpdate} todoUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTodoV1TodosTodoIdPatch: async (todoId: string, todoUpdate: TodoUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'todoId' is not null or undefined
            assertParamExists('updateTodoV1TodosTodoIdPatch', 'todoId', todoId)
            // verify required parameter 'todoUpdate' is not null or undefined
            assertParamExists('updateTodoV1TodosTodoIdPatch', 'todoUpdate', todoUpdate)
            const localVarPath = `/v1/todos/{todo_id}`
                .replace(`{${"todo_id"}}`, encodeURIComponent(String(todoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(todoUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TodosApi - functional programming interface
 */
export const TodosApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TodosApiAxiosParamCreator(configuration)
    return {
        /**
         * 새 Todo 생성  Todo는 독립적인 엔티티입니다. deadline이 있으면 별도의 Schedule이 자동으로 생성됩니다.
         * @summary Create Todo
         * @param {TodoCreate} todoCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTodoV1TodosPost(todoCreate: TodoCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TodoRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTodoV1TodosPost(todoCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TodosApi.createTodoV1TodosPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Todo 삭제
         * @summary Delete Todo
         * @param {string} todoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTodoV1TodosTodoIdDelete(todoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTodoV1TodosTodoIdDelete(todoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TodosApi.deleteTodoV1TodosTodoIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 프리셋 상세 조회  프리셋의 TagGroup, Tag, Todo 구조를 미리 확인할 수 있습니다.
         * @summary Get Preset
         * @param {string} presetName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresetV1TodosPresetsPresetNameGet(presetName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Preset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPresetV1TodosPresetsPresetNameGet(presetName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TodosApi.getPresetV1TodosPresetsPresetNameGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Todo의 현재 활성 타이머 조회 (RUNNING 또는 PAUSED, 공유된 Todo 포함)  활성 타이머가 없으면 404를 반환합니다. Schedule의 /schedules/{schedule_id}/timers/active 엔드포인트와 동일한 패턴입니다.
         * @summary Get Todo Active Timer
         * @param {string} todoId 
         * @param {boolean} [includeTodo] Todo 정보 포함 여부 (기본값: false)
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTodoActiveTimerV1TodosTodoIdTimersActiveGet(todoId: string, includeTodo?: boolean, timezone?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimerRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTodoActiveTimerV1TodosTodoIdTimersActiveGet(todoId, includeTodo, timezone, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TodosApi.getTodoActiveTimerV1TodosTodoIdTimersActiveGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Todo 통계 조회  그룹별 태그 통계를 반환합니다. group_id가 지정되면 해당 그룹의 태그만 집계합니다.
         * @summary Get Todo Stats
         * @param {string | null} [groupId] 필터링할 태그 그룹 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTodoStatsV1TodosStatsGet(groupId?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TodoStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTodoStatsV1TodosStatsGet(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TodosApi.getTodoStatsV1TodosStatsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Todo의 모든 타이머 조회 (공유된 Todo 포함)  Schedule의 /schedules/{schedule_id}/timers 엔드포인트와 동일한 패턴입니다.
         * @summary Get Todo Timers
         * @param {string} todoId 
         * @param {boolean} [includeTodo] Todo 정보 포함 여부 (기본값: false)
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTodoTimersV1TodosTodoIdTimersGet(todoId: string, includeTodo?: boolean, timezone?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TimerRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTodoTimersV1TodosTodoIdTimersGet(todoId, includeTodo, timezone, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TodosApi.getTodoTimersV1TodosTodoIdTimersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 프리셋으로 Todo 초기화  지정한 프리셋을 사용하여 TagGroup, Tag, Todo를 일괄 생성합니다.  - TagGroup 1개 생성 - 프리셋에 정의된 Tag들 생성 - 프리셋에 정의된 Todo들 생성 (계층 구조 지원)
         * @summary Initialize From Preset
         * @param {string} presetName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initializeFromPresetV1TodosInitializePresetNamePost(presetName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PresetInitializeResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initializeFromPresetV1TodosInitializePresetNamePost(presetName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TodosApi.initializeFromPresetV1TodosInitializePresetNamePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 사용 가능한 프리셋 목록 조회  프리셋은 TagGroup, Tag, Todo를 일괄 생성하기 위한 템플릿입니다.
         * @summary List Presets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPresetsV1TodosPresetsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PresetInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPresetsV1TodosPresetsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TodosApi.listPresetsV1TodosPresetsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ID로 Todo 조회 (공유된 Todo 포함)  본인 소유 Todo 또는 공유 접근 권한이 있는 Todo를 조회합니다. 접근 권한이 없으면 403 Forbidden을 반환합니다.
         * @summary Read Todo
         * @param {string} todoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readTodoV1TodosTodoIdGet(todoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TodoRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readTodoV1TodosTodoIdGet(todoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TodosApi.readTodoV1TodosTodoIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Todo 목록 조회 (태그/그룹 필터링 지원)  조회 범위 (scope): - mine: 내 Todo만 (기본값) - shared: 공유된 타인의 Todo만 - all: 내 Todo + 공유된 Todo  그룹 필터링: - group_ids: 해당 그룹에 속한 Todo 반환   - tag_group_id로 직접 연결된 Todo   - OR 해당 그룹의 태그를 가진 Todo  태그 필터링: - tag_ids: AND 방식 (모든 지정 태그를 포함한 Todo만 반환) - 태그 필터 시 조상 노드도 포함 (orphan 방지)  응답의 include_reason 필드: - MATCH: 필터 조건에 직접 매칭된 Todo - ANCESTOR: 매칭된 Todo의 조상이라 포함된 Todo  둘 다 지정 시: 그룹 필터링 후 태그 필터링 적용
         * @summary Read Todos
         * @param {ResourceScope} [scope] 조회 범위: mine(내 Todo만), shared(공유된 Todo만), all(모두)
         * @param {Array<string> | null} [tagIds] 태그 ID 리스트 (AND 방식: 모든 지정 태그를 포함한 Todo만 반환)
         * @param {Array<string> | null} [groupIds] 태그 그룹 ID 리스트 (해당 그룹에 속한 Todo 반환 - 직접 연결 또는 태그 기반)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readTodosV1TodosGet(scope?: ResourceScope, tagIds?: Array<string> | null, groupIds?: Array<string> | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TodoRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readTodosV1TodosGet(scope, tagIds, groupIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TodosApi.readTodosV1TodosGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Todo 업데이트  title, description, tag_ids, deadline, parent_id, status를 업데이트할 수 있습니다.  deadline 변경 시: - deadline 추가: 새 Schedule 생성 - deadline 변경: 기존 Schedule 업데이트 - deadline 제거: 기존 Schedule 삭제
         * @summary Update Todo
         * @param {string} todoId 
         * @param {TodoUpdate} todoUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTodoV1TodosTodoIdPatch(todoId: string, todoUpdate: TodoUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TodoRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTodoV1TodosTodoIdPatch(todoId, todoUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TodosApi.updateTodoV1TodosTodoIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TodosApi - factory interface
 */
export const TodosApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TodosApiFp(configuration)
    return {
        /**
         * 새 Todo 생성  Todo는 독립적인 엔티티입니다. deadline이 있으면 별도의 Schedule이 자동으로 생성됩니다.
         * @summary Create Todo
         * @param {TodoCreate} todoCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTodoV1TodosPost(todoCreate: TodoCreate, options?: RawAxiosRequestConfig): AxiosPromise<TodoRead> {
            return localVarFp.createTodoV1TodosPost(todoCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Todo 삭제
         * @summary Delete Todo
         * @param {string} todoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTodoV1TodosTodoIdDelete(todoId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.deleteTodoV1TodosTodoIdDelete(todoId, options).then((request) => request(axios, basePath));
        },
        /**
         * 프리셋 상세 조회  프리셋의 TagGroup, Tag, Todo 구조를 미리 확인할 수 있습니다.
         * @summary Get Preset
         * @param {string} presetName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresetV1TodosPresetsPresetNameGet(presetName: string, options?: RawAxiosRequestConfig): AxiosPromise<Preset> {
            return localVarFp.getPresetV1TodosPresetsPresetNameGet(presetName, options).then((request) => request(axios, basePath));
        },
        /**
         * Todo의 현재 활성 타이머 조회 (RUNNING 또는 PAUSED, 공유된 Todo 포함)  활성 타이머가 없으면 404를 반환합니다. Schedule의 /schedules/{schedule_id}/timers/active 엔드포인트와 동일한 패턴입니다.
         * @summary Get Todo Active Timer
         * @param {string} todoId 
         * @param {boolean} [includeTodo] Todo 정보 포함 여부 (기본값: false)
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTodoActiveTimerV1TodosTodoIdTimersActiveGet(todoId: string, includeTodo?: boolean, timezone?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<TimerRead> {
            return localVarFp.getTodoActiveTimerV1TodosTodoIdTimersActiveGet(todoId, includeTodo, timezone, options).then((request) => request(axios, basePath));
        },
        /**
         * Todo 통계 조회  그룹별 태그 통계를 반환합니다. group_id가 지정되면 해당 그룹의 태그만 집계합니다.
         * @summary Get Todo Stats
         * @param {string | null} [groupId] 필터링할 태그 그룹 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTodoStatsV1TodosStatsGet(groupId?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<TodoStats> {
            return localVarFp.getTodoStatsV1TodosStatsGet(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Todo의 모든 타이머 조회 (공유된 Todo 포함)  Schedule의 /schedules/{schedule_id}/timers 엔드포인트와 동일한 패턴입니다.
         * @summary Get Todo Timers
         * @param {string} todoId 
         * @param {boolean} [includeTodo] Todo 정보 포함 여부 (기본값: false)
         * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTodoTimersV1TodosTodoIdTimersGet(todoId: string, includeTodo?: boolean, timezone?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<TimerRead>> {
            return localVarFp.getTodoTimersV1TodosTodoIdTimersGet(todoId, includeTodo, timezone, options).then((request) => request(axios, basePath));
        },
        /**
         * 프리셋으로 Todo 초기화  지정한 프리셋을 사용하여 TagGroup, Tag, Todo를 일괄 생성합니다.  - TagGroup 1개 생성 - 프리셋에 정의된 Tag들 생성 - 프리셋에 정의된 Todo들 생성 (계층 구조 지원)
         * @summary Initialize From Preset
         * @param {string} presetName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initializeFromPresetV1TodosInitializePresetNamePost(presetName: string, options?: RawAxiosRequestConfig): AxiosPromise<PresetInitializeResult> {
            return localVarFp.initializeFromPresetV1TodosInitializePresetNamePost(presetName, options).then((request) => request(axios, basePath));
        },
        /**
         * 사용 가능한 프리셋 목록 조회  프리셋은 TagGroup, Tag, Todo를 일괄 생성하기 위한 템플릿입니다.
         * @summary List Presets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPresetsV1TodosPresetsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<PresetInfo>> {
            return localVarFp.listPresetsV1TodosPresetsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * ID로 Todo 조회 (공유된 Todo 포함)  본인 소유 Todo 또는 공유 접근 권한이 있는 Todo를 조회합니다. 접근 권한이 없으면 403 Forbidden을 반환합니다.
         * @summary Read Todo
         * @param {string} todoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTodoV1TodosTodoIdGet(todoId: string, options?: RawAxiosRequestConfig): AxiosPromise<TodoRead> {
            return localVarFp.readTodoV1TodosTodoIdGet(todoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Todo 목록 조회 (태그/그룹 필터링 지원)  조회 범위 (scope): - mine: 내 Todo만 (기본값) - shared: 공유된 타인의 Todo만 - all: 내 Todo + 공유된 Todo  그룹 필터링: - group_ids: 해당 그룹에 속한 Todo 반환   - tag_group_id로 직접 연결된 Todo   - OR 해당 그룹의 태그를 가진 Todo  태그 필터링: - tag_ids: AND 방식 (모든 지정 태그를 포함한 Todo만 반환) - 태그 필터 시 조상 노드도 포함 (orphan 방지)  응답의 include_reason 필드: - MATCH: 필터 조건에 직접 매칭된 Todo - ANCESTOR: 매칭된 Todo의 조상이라 포함된 Todo  둘 다 지정 시: 그룹 필터링 후 태그 필터링 적용
         * @summary Read Todos
         * @param {ResourceScope} [scope] 조회 범위: mine(내 Todo만), shared(공유된 Todo만), all(모두)
         * @param {Array<string> | null} [tagIds] 태그 ID 리스트 (AND 방식: 모든 지정 태그를 포함한 Todo만 반환)
         * @param {Array<string> | null} [groupIds] 태그 그룹 ID 리스트 (해당 그룹에 속한 Todo 반환 - 직접 연결 또는 태그 기반)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTodosV1TodosGet(scope?: ResourceScope, tagIds?: Array<string> | null, groupIds?: Array<string> | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<TodoRead>> {
            return localVarFp.readTodosV1TodosGet(scope, tagIds, groupIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Todo 업데이트  title, description, tag_ids, deadline, parent_id, status를 업데이트할 수 있습니다.  deadline 변경 시: - deadline 추가: 새 Schedule 생성 - deadline 변경: 기존 Schedule 업데이트 - deadline 제거: 기존 Schedule 삭제
         * @summary Update Todo
         * @param {string} todoId 
         * @param {TodoUpdate} todoUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTodoV1TodosTodoIdPatch(todoId: string, todoUpdate: TodoUpdate, options?: RawAxiosRequestConfig): AxiosPromise<TodoRead> {
            return localVarFp.updateTodoV1TodosTodoIdPatch(todoId, todoUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TodosApi - object-oriented interface
 */
export class TodosApi extends BaseAPI {
    /**
     * 새 Todo 생성  Todo는 독립적인 엔티티입니다. deadline이 있으면 별도의 Schedule이 자동으로 생성됩니다.
     * @summary Create Todo
     * @param {TodoCreate} todoCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createTodoV1TodosPost(todoCreate: TodoCreate, options?: RawAxiosRequestConfig) {
        return TodosApiFp(this.configuration).createTodoV1TodosPost(todoCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Todo 삭제
     * @summary Delete Todo
     * @param {string} todoId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteTodoV1TodosTodoIdDelete(todoId: string, options?: RawAxiosRequestConfig) {
        return TodosApiFp(this.configuration).deleteTodoV1TodosTodoIdDelete(todoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 프리셋 상세 조회  프리셋의 TagGroup, Tag, Todo 구조를 미리 확인할 수 있습니다.
     * @summary Get Preset
     * @param {string} presetName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPresetV1TodosPresetsPresetNameGet(presetName: string, options?: RawAxiosRequestConfig) {
        return TodosApiFp(this.configuration).getPresetV1TodosPresetsPresetNameGet(presetName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Todo의 현재 활성 타이머 조회 (RUNNING 또는 PAUSED, 공유된 Todo 포함)  활성 타이머가 없으면 404를 반환합니다. Schedule의 /schedules/{schedule_id}/timers/active 엔드포인트와 동일한 패턴입니다.
     * @summary Get Todo Active Timer
     * @param {string} todoId 
     * @param {boolean} [includeTodo] Todo 정보 포함 여부 (기본값: false)
     * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTodoActiveTimerV1TodosTodoIdTimersActiveGet(todoId: string, includeTodo?: boolean, timezone?: string | null, options?: RawAxiosRequestConfig) {
        return TodosApiFp(this.configuration).getTodoActiveTimerV1TodosTodoIdTimersActiveGet(todoId, includeTodo, timezone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Todo 통계 조회  그룹별 태그 통계를 반환합니다. group_id가 지정되면 해당 그룹의 태그만 집계합니다.
     * @summary Get Todo Stats
     * @param {string | null} [groupId] 필터링할 태그 그룹 ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTodoStatsV1TodosStatsGet(groupId?: string | null, options?: RawAxiosRequestConfig) {
        return TodosApiFp(this.configuration).getTodoStatsV1TodosStatsGet(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Todo의 모든 타이머 조회 (공유된 Todo 포함)  Schedule의 /schedules/{schedule_id}/timers 엔드포인트와 동일한 패턴입니다.
     * @summary Get Todo Timers
     * @param {string} todoId 
     * @param {boolean} [includeTodo] Todo 정보 포함 여부 (기본값: false)
     * @param {string | null} [timezone] 타임존 (예: UTC, +09:00, Asia/Seoul). 지정하지 않으면 UTC로 반환
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTodoTimersV1TodosTodoIdTimersGet(todoId: string, includeTodo?: boolean, timezone?: string | null, options?: RawAxiosRequestConfig) {
        return TodosApiFp(this.configuration).getTodoTimersV1TodosTodoIdTimersGet(todoId, includeTodo, timezone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 프리셋으로 Todo 초기화  지정한 프리셋을 사용하여 TagGroup, Tag, Todo를 일괄 생성합니다.  - TagGroup 1개 생성 - 프리셋에 정의된 Tag들 생성 - 프리셋에 정의된 Todo들 생성 (계층 구조 지원)
     * @summary Initialize From Preset
     * @param {string} presetName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public initializeFromPresetV1TodosInitializePresetNamePost(presetName: string, options?: RawAxiosRequestConfig) {
        return TodosApiFp(this.configuration).initializeFromPresetV1TodosInitializePresetNamePost(presetName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 사용 가능한 프리셋 목록 조회  프리셋은 TagGroup, Tag, Todo를 일괄 생성하기 위한 템플릿입니다.
     * @summary List Presets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listPresetsV1TodosPresetsGet(options?: RawAxiosRequestConfig) {
        return TodosApiFp(this.configuration).listPresetsV1TodosPresetsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ID로 Todo 조회 (공유된 Todo 포함)  본인 소유 Todo 또는 공유 접근 권한이 있는 Todo를 조회합니다. 접근 권한이 없으면 403 Forbidden을 반환합니다.
     * @summary Read Todo
     * @param {string} todoId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public readTodoV1TodosTodoIdGet(todoId: string, options?: RawAxiosRequestConfig) {
        return TodosApiFp(this.configuration).readTodoV1TodosTodoIdGet(todoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Todo 목록 조회 (태그/그룹 필터링 지원)  조회 범위 (scope): - mine: 내 Todo만 (기본값) - shared: 공유된 타인의 Todo만 - all: 내 Todo + 공유된 Todo  그룹 필터링: - group_ids: 해당 그룹에 속한 Todo 반환   - tag_group_id로 직접 연결된 Todo   - OR 해당 그룹의 태그를 가진 Todo  태그 필터링: - tag_ids: AND 방식 (모든 지정 태그를 포함한 Todo만 반환) - 태그 필터 시 조상 노드도 포함 (orphan 방지)  응답의 include_reason 필드: - MATCH: 필터 조건에 직접 매칭된 Todo - ANCESTOR: 매칭된 Todo의 조상이라 포함된 Todo  둘 다 지정 시: 그룹 필터링 후 태그 필터링 적용
     * @summary Read Todos
     * @param {ResourceScope} [scope] 조회 범위: mine(내 Todo만), shared(공유된 Todo만), all(모두)
     * @param {Array<string> | null} [tagIds] 태그 ID 리스트 (AND 방식: 모든 지정 태그를 포함한 Todo만 반환)
     * @param {Array<string> | null} [groupIds] 태그 그룹 ID 리스트 (해당 그룹에 속한 Todo 반환 - 직접 연결 또는 태그 기반)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public readTodosV1TodosGet(scope?: ResourceScope, tagIds?: Array<string> | null, groupIds?: Array<string> | null, options?: RawAxiosRequestConfig) {
        return TodosApiFp(this.configuration).readTodosV1TodosGet(scope, tagIds, groupIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Todo 업데이트  title, description, tag_ids, deadline, parent_id, status를 업데이트할 수 있습니다.  deadline 변경 시: - deadline 추가: 새 Schedule 생성 - deadline 변경: 기존 Schedule 업데이트 - deadline 제거: 기존 Schedule 삭제
     * @summary Update Todo
     * @param {string} todoId 
     * @param {TodoUpdate} todoUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateTodoV1TodosTodoIdPatch(todoId: string, todoUpdate: TodoUpdate, options?: RawAxiosRequestConfig) {
        return TodosApiFp(this.configuration).updateTodoV1TodosTodoIdPatch(todoId, todoUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



